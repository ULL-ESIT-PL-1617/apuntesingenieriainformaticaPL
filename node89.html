<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Listas</TITLE>
<META NAME="description" CONTENT="Listas">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node90.html">
<LINK REL="previous" HREF="node88.html">
<LINK REL="up" HREF="node85.html">
<LINK REL="next" HREF="node90.html">
</HEAD>

<BODY >

<A NAME="tex2html2618"
  HREF="node90.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2612"
  HREF="node85.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2606"
  HREF="node88.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2614"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2616"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2619"
  HREF="node90.html">Pseudo sub-reglas</A>
<B>Sup:</B> <A NAME="tex2html2613"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
<B> Ant:</B> <A NAME="tex2html2607"
  HREF="node88.html">Renombrando los resultados de</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html2620"
  HREF="node89.html#SECTION008114010000000000000">El operador de cierre positivo</A>
<LI><A NAME="tex2html2621"
  HREF="node89.html#SECTION008114020000000000000">Operadores de listas y espacios en blanco</A>
<LI><A NAME="tex2html2622"
  HREF="node89.html#SECTION008114030000000000000">Una Solución al problema de recordar los resultados de una lista: El uso de brackets</A>
<LI><A NAME="tex2html2623"
  HREF="node89.html#SECTION008114040000000000000">Otra forma de resolver las colisiones de nombres: salvarlos en una lista</A>
<LI><A NAME="tex2html2624"
  HREF="node89.html#SECTION008114050000000000000">Aliasing de listas</A>
<LI><A NAME="tex2html2625"
  HREF="node89.html#SECTION008114060000000000000">Caveat: Cierres y Warnings</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION008114000000000000000">
Listas</A>
</H2>

<P>

<H4><A NAME="SECTION008114010000000000000">
El operador de cierre positivo</A>
</H4>
  

<P>
<BLOCKQUOTE><I>If a subrule call is quantified with a repetition specifier:
</I></BLOCKQUOTE>
<P><PRE>
           &lt;rule: file_sequence&gt;
               &lt;file&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>then each repeated match overwrites the corresponding entry in the
surrounding rule’s result-hash, so only the result of the final
repetition will be
retained. That is, if the above example matched the string  <code>foo.pl bar.py baz.php</code>, 
then the result-hash would contain:
</I></BLOCKQUOTE>
<P><PRE>
           file_sequence {
               ""   =&gt; 'foo.pl bar.py baz.php',
               file =&gt; 'baz.php',
           }
</PRE>

<P>

<H4><A NAME="SECTION008114020000000000000">
Operadores de listas y espacios en blanco</A>
</H4>
  

<P>
Existe un caveat con el uso de los operadores de repetición
y el manejo de los blancos. Véase el siguiente programa:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;numbers&gt;
11
12        &lt;rule: numbers&gt;
13          (&lt;number&gt;)+
14
15        &lt;token: number&gt; \s*\d+
16      }xms;
17  };
18
19  while (my $input = &lt;&gt;) {
20      if ($input =~ m{$rbb}) {
21          say("matches: &lt;$&amp;&gt;");
22          say Dumper \%/;
23      }
24  }
</PRE>
Obsérvese el uso explícito 
de espacios <code>\s*\d+</code> en la definición de <code>number</code>.

<P>
Sigue un ejemplo de ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: &lt;1 2 3 4&gt;
$VAR1 = {
          '' =&gt; '1 2 3 4',
          'numbers' =&gt; {
                         '' =&gt; '1 2 3 4',
                         'number' =&gt; ' 4'
                       }
        };
</PRE>

<P>
Si se eliminan los blancos de la definición de 
<code>number</code>: 
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          (&lt;number&gt;)+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
se obtiene una conducta que puede sorprender:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: &lt;12&gt;
$VAR1 = {
          '' =&gt; '12',
          'numbers' =&gt; {
                         '' =&gt; '12',
                         'number' =&gt; '12'
                       }
        };
</PRE>

<P>
La explicación está en la documentación: véase la sección <A NAME="tex2html192"
  HREF="http://search.cpan.org/~dconway/Regexp-Grammars/lib/Regexp/Grammars.pm#Grammar_syntax">Grammar Syntax</A>:
<BLOCKQUOTE><I><code>&lt;rule: IDENTIFIER&gt;</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Define a rule whose name is specified by the supplied identifier.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Everything following the <code>&lt;rule:...&gt;</code> directive (up to the next <code>&lt;rule:...&gt;</code> or <code>&lt;token:...&gt;</code> directive) 
is treated as part of the rule being defined.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><B>Any whitespace in the rule is replaced by a call to the</B> <code>&lt;.ws&gt;</code> subrule (which defaults to matching <code>\s*</code>, but may be explicitly redefined).
</I></BLOCKQUOTE>
<P>
También podríamos haber resuelto el problema introduciendo un
blanco explícito dentro del cierre positivo:

<P>
<PRE>
      &lt;rule: numbers&gt;
        (&lt;number&gt; )+

      &lt;token: number&gt; \d+
</PRE>

<P>

<H4><A NAME="SECTION008114030000000000000">
Una Solución al problema de recordar los resultados de una lista: El uso de brackets</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Usually, that’s not the desired outcome, so <A NAME="tex2html193"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
provides
another mechanism by which to call a subrule; one that saves all
repetitions of its results.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>A regular subrule call consists of the rule’s name surrounded by angle
brackets. If, instead, you surround the rule’s name with  <code>&lt;[...]&gt;</code>
(angle and square brackets) like so:
</I></BLOCKQUOTE>
<P><PRE>
           &lt;rule: file_sequence&gt;
               &lt;[file]&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>then the rule is invoked in exactly the same way, but the result of that
submatch is pushed onto an array nested inside the appropriate result-hash
entry. In other words, if the above example matched the same  
<code>foo.pl bar.py baz.php</code> string, the result-hash would contain:
</I></BLOCKQUOTE>
<P><PRE>
           file_sequence {
               ""   =&gt; 'foo.pl bar.py baz.php',
               file =&gt; [ 'foo.pl', 'bar.py', 'baz.php' ],
           }
</PRE>

<P>
Teniendo en cuenta lo dicho anteriormente sobre los blancos
dentro de los cuantificadores, es necesario introducir
blancos dentro del operador de repetición:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        &lt;numbers&gt;
    11
    12        &lt;rule: numbers&gt;
    13          (?:  &lt;[number]&gt; )+
    14
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
Al ejecutar este programa obtenemos:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: &lt;1 2 3 4
&gt;
$VAR1 = {
          '' =&gt; '1 2 3 4
',
          'numbers' =&gt; {
                         '' =&gt; '1 2 3 4
',
                         'number' =&gt; [ '1', '2', '3', '4' ]
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION008114040000000000000">
Otra forma de resolver las colisiones de nombres: salvarlos en una lista</A>
</H4>
  

<P>
<BLOCKQUOTE><I>This <B>listifying subrule call</B> can also be useful for non-repeated
subrule calls, if the same subrule is invoked in several places in a
grammar. For example if a cmdline option could be given either one or
two values, you might parse it:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: size_option&gt;   
        -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?
</PRE>
<P>
<BLOCKQUOTE><I>The result-hash entry for <code>size</code> would then always contain an array,
with either one or two elements, depending on the input being parsed.
</I></BLOCKQUOTE>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?
16
17        &lt;token: size&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: &lt;$&amp;&gt;");
24          say Dumper \%/;
25      }
26  }
</PRE>
Veamos su comportamiento con diferentes entradas:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: &lt;ls -size 4
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 4
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 4
',
                                            'size' =&gt; [ '4' ]
                                          },
                         '' =&gt; 'ls -size 4
'
                       }
        };

ls -size 2x8
matches: &lt;ls -size 2x8
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 2x8
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 2x8
',
                                            'size' =&gt; [ '2', '8' ]
                                          },
                         '' =&gt; 'ls -size 2x8
'
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION008114050000000000000">
Aliasing de listas</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Listifying subrules can also be given aliases, just like ordinary
subrules. The alias is always specified inside the square brackets:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: size_option&gt;   
        -size &lt;[size=pos_integer]&gt; (?: x &lt;[size=pos_integer]&gt; )?
</PRE>
<P>
<BLOCKQUOTE><I>Here, the sizes are parsed using the <code>pos_integer</code> rule, 
but saved in the result-hash in an array under the key <code>size</code>.
</I></BLOCKQUOTE>

<P>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size=int]&gt; (?: x &lt;[size=int]&gt; )?
16
17        &lt;token: int&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: &lt;$&amp;&gt;");
24          say Dumper \%/;
25      }
26  }
</PRE>
Veamos el resultado de una ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: &lt;ls -size 2x4
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 2x4
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 2x4
',
                                            'size' =&gt; [
                                                        '2',
                                                        '4'
                                                      ]
                                          },
                         '' =&gt; 'ls -size 2x4
'
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION008114060000000000000">
Caveat: Cierres y Warnings</A>
</H4>
  

<P>
En este ejemplo aparece <code>&lt;number&gt;+</code> sin 
corchetes ni paréntesis:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          &lt;number&gt;+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
Este programa produce un mensaje de advertencia:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule &lt;number&gt;+ will only capture its final match
       | (Did you mean &lt;[number]&gt;+ instead?)
       |
</PRE>

<P>
Si se quiere evitar el mensaje y se está dispuesto a asumir la pérdida
de los valores asociados con los elementos de la lista se deberán poner 
el operando entre paréntesis (con o sin memoria).

<P>
Esto es lo que dice la documentación sobre este warning:

<P>
<BLOCKQUOTE><I><code>Repeated subrule &lt;rule&gt; will only capture its final match</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>You specified a subrule call with a repetition qualifier, such as:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;ListElem&gt;*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;ListElem&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>Because each subrule call saves its result in a hash entry of the
same name, each repeated match will overwrite the previous ones,
so only the last match will ultimately be saved. If you want to
save all the matches, you need to tell <A NAME="tex2html194"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
to save the
sequence of results as a nested array within the hash entry, like so:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;[ListElem]&gt;*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;[ListElem]&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>If you really did intend to throw away every result but the final
one, you can silence the warning by placing the subrule call inside
any kind of parentheses. For example:
</I></BLOCKQUOTE>
<P><PRE>
        (&lt;ListElem&gt;)*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        (?: &lt;ListElem&gt; )+
</PRE>
<P>

<P>
<HR>
<A NAME="tex2html2618"
  HREF="node90.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2612"
  HREF="node85.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2606"
  HREF="node88.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2614"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2616"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2619"
  HREF="node90.html">Pseudo sub-reglas</A>
<B>Sup:</B> <A NAME="tex2html2613"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
<B> Ant:</B> <A NAME="tex2html2607"
  HREF="node88.html">Renombrando los resultados de</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
