<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Realización del AAA para Tutu en Perl</TITLE>
<META NAME="description" CONTENT="Realización del AAA para Tutu en Perl">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node150.html">
<LINK REL="previous" HREF="node148.html">
<LINK REL="up" HREF="node147.html">
<LINK REL="next" HREF="node150.html">
</HEAD>

<BODY >

<A NAME="tex2html3621"
  HREF="node150.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3615"
  HREF="node147.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3609"
  HREF="node148.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3617"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3619"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3622"
  HREF="node150.html">AAA: Otros tipos de</A>
<B>Sup:</B> <A NAME="tex2html3616"
  HREF="node147.html">Árbol de Análisis Abstracto</A>
<B> Ant:</B> <A NAME="tex2html3610"
  HREF="node148.html">Lenguajes Árbol y Gramáticas</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->

<H2><A NAME="SECTION00992000000000000000">
Realización del AAA para Tutu en Perl</A>
</H2>
En la sección 
<A HREF="node126.html#subsection:introduccion">4.6.1</A>
nos limitamos a realizar un recorrido del árbol
de análisis sintáctico concreto. En esta sección construimos un 
<A NAME="10083"></A><B>árbol de análisis sintáctico abstracto</B>. Este proceso puede
verse como <B>la traducción desde el lenguaje de árboles concretos
hasta el lenguaje de árboles abstractos</B>.

<P>
<P>
<DIV><A NAME="definition:tutuast"><B>Definición  4.9.7</B></A> &nbsp; 
<I>La gramática árbol extendida que especifica los árboles AAA
para el compilador de Tutu es esta:
</I>
<P>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><I>
  1 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img246.png"
 ALT="$ prog$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow PROGRAM(decls, sts)$
 -->
<IMG
 WIDTH="209" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img247.png"
 ALT="$ \rightarrow PROGRAM(decls, sts)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  2 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="43" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img248.png"
 ALT="$ decls$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow$
 -->
<IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$ \rightarrow$">
 list <IMG
 WIDTH="35" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img249.png"
 ALT="$ decl$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  3 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="27" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img250.png"
 ALT="$ sts$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow$
 -->
<IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$ \rightarrow$">
 list <IMG
 WIDTH="19" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img216.png"
 ALT="$ st$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  4 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="35" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img249.png"
 ALT="$ decl$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow INT(idlist)$
 -->
<IMG
 WIDTH="119" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img251.png"
 ALT="$ \rightarrow INT(idlist)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  5 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="35" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img249.png"
 ALT="$ decl$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow STRING(idlist)$
 -->
<IMG
 WIDTH="158" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img252.png"
 ALT="$ \rightarrow STRING(idlist)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  6 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="46" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img253.png"
 ALT="$ idlist$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow$
 -->
<IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$ \rightarrow$">
 list <IMG
 WIDTH="108" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img254.png"
 ALT="$ SIMPLEID$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  7 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="19" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img216.png"
 ALT="$ st$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow ASSIGN(LEFTVALUE, expr)$
 -->
<IMG
 WIDTH="277" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img217.png"
 ALT="$ \rightarrow ASSIGN(LEFTVALUE, expr)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  8 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="19" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img216.png"
 ALT="$ st$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow PRINT(expr)$
 -->
<IMG
 WIDTH="140" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img218.png"
 ALT="$ \rightarrow PRINT(expr)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
  9 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img121.png"
 ALT="$ expr$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow PLUS(expr, expr)$
 -->
<IMG
 WIDTH="169" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img219.png"
 ALT="$ \rightarrow PLUS(expr, expr)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
 10 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img121.png"
 ALT="$ expr$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow TIMES(expr, expr)$
 -->
<IMG
 WIDTH="184" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img220.png"
 ALT="$ \rightarrow TIMES(expr, expr)$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
 11 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img121.png"
 ALT="$ expr$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow NUM$
 -->
<IMG
 WIDTH="76" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img221.png"
 ALT="$ \rightarrow NUM$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
 12 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img121.png"
 ALT="$ expr$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow ID$
 -->
<IMG
 WIDTH="51" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img222.png"
 ALT="$ \rightarrow ID$">
</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
 13 </I></TD>
<TD ALIGN="LEFT"><I> <IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img121.png"
 ALT="$ expr$">
 </I></TD>
<TD ALIGN="LEFT"><I><!-- MATH
 $\rightarrow STR$
 -->
<IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img223.png"
 ALT="$ \rightarrow STR$">
</I></TD>
</TR>
</TABLE></DIV></DIV><P></P>

<P>
Hemos extendido el concepto de gramática 
árbol con el concepto de <A NAME="10085"></A><B>lista de no terminales</B>. 
A la hora de construir las estructuras de datos
las listas de variables se van a traducir por listas de árboles.

<P>
Por ejemplo, un árbol abstracto para el programa

<P>
<PRE>
int a,b;
string c, d;
a = 4;
p a
</PRE>

<P>
Sería de la forma:

<P>
<PRE>
PROGRAM(
         DECLS[INT[ID, ID], STRING[ID, ID]], 
         STS[ASSIGN(LEFTVALUE, NUM), PRINT(ID)]
       )
</PRE>

<P>
Donde los corchetes indican listas y los paréntesis tuplas.

<P>
Para llevar a cabo la traducción deberemos 
tomar decisiones sobre que forma de representación nos conviene.
Cada nodo del AAA va a ser un objeto y la clase indicará si es un nodo
suma, producto, una declaración, una asignación, etc. 

<P>
Cada nodo del árbol AAA va a ser un objeto. 
De este modo el acceso a los atributos del nodo se hará a través de
los métodos asociados. Además, el procedimiento de traducción
al lenguaje objetivo depende del tipo de nodo. Así por ejemplo,
el método <B>traducción</B>
es diferente para un nodo de tipo <IMG
 WIDTH="56" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img228.png"
 ALT="$ PLUS$">
 que para otro de tipo <IMG
 WIDTH="80" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img225.png"
 ALT="$ ASSIGN$">
.

<P>
Resumamos antes de entrar en detalle, la forma de manejar los
objetos en Perl:

<P>

<UL>
<LI>Para crear una <A NAME="10087"></A><B>clase</B> se construye un ``package'':
<PRE>
package NUM;
</PRE>
</LI>
<LI>Para crea un <A NAME="10089"></A><B>método</B> se escribe una subrutina:
<PRE>
package NUM;
sub incr { my $self = shift; $self-&gt;{VAL}++ }
</PRE>
el primer argumento de un método suele ser la referencia al 
objeto en cuestión.
</LI>
<LI>Para crear un <A NAME="10091"></A><B>objeto</B>, se bendice (``bless'') una referencia.
Los objetos Perl son datos normales como hashes y arrays que han sido 
``bendecidos'' en un paquete. Por ejemplo:
<PRE>
my $a = bless {VAL =&gt; 4}, 'NUM';
</PRE>
crea un objeto referenciado por <code>$a</code> que pertenece a la clase <code>NUM</code>.
Los métodos del objeto son las subrutinas que aparecen en el <code>package NUM</code>.
</LI>
<LI>Para referirse a un método de un objeto se usa la sintáxis ``flecha'':
<PRE>
$a-&gt;incr;
</PRE>
Cuando se usa la sintáxis flecha, el primer argumento de la rutina es 
la referencia al objeto, esto es, la llamada anterior es equivalente a
<code>NUM::incr($a)</code>
</LI>
<LI>Constructores: En Perl son rutinas que retornan una referencia a un objeto 
recién creado e inicializado
<PRE>
sub new { my ($class, $value) = @_; return bless {VAL =&gt; $value}, $class; }
</PRE>
Normalmente se llaman usando la sintáxis flecha, pero a la izquierda de la
flecha va el nombre de la clase. Por ejemplo:

<P>
<code>my $a = NUM-&gt;new(4)</code> 

<P>
En este caso,
el primer argumento es el nombre de la clase. La llamada anterior es
equivalente a 

<P>
<code>NUM::new('NUM', 4)</code>
</LI>
</UL>

<P>
Volviendo a nuestro problema de crear el AAA, para crear los 
objetos de las diferentes clases de nodos
usaremos el módulo  <code>Class::MakeMethods::Emulator::MethodMaker</code>
(véase la línea 9):

<P>
<PRE>
 1 package PL::Syntax::Analysis;
 2
 3 use 5.006;
 4 use strict;
 5 use warnings;
 6 use Data::Dumper;
 7 use IO::File;
 8 use Class::MakeMethods::Emulator::MethodMaker '-sugar';
 9
10 require Exporter;
11 our @ISA = qw(Exporter);
12 our @EXPORT = qw( );
13 our $VERSION = '0.02';
14
15 #######################################################
16
17 # Grammar:
18 # P : DD L      | L
19 # DD: D ';' DD  | D ';'
20 # D : int I     | string I
21 # L : S         | S ; L
22 # S : ID '=' E  | p E  | epsilon
23 # E : T '+' E   | T
24 # T : F '*' T   | F
25 # F : '(' E ')' | id | num | str
26 # I : id ',' I  | id
</PRE>

<P>
Hemos aislado la fase de análisis sintáctica en un módulo
aparte denominado <code>PL::Syntax::Analysis</code>.
La dependencia se actualiza en <code>Makefile.PL</code>:
<PRE>
PL0506/04sintactico/PL-Tutu$ cat -n Makefile.PL
  1  use 5.008004;
  2  use ExtUtils::MakeMaker;
  3  WriteMakefile(
  4      NAME              =&gt; 'PL::Tutu',
  5      VERSION_FROM      =&gt; 'lib/PL/Tutu.pm', # finds $VERSION
  6      PREREQ_PM         =&gt; {Class::MakeMethods::Emulator::MethodMaker =&gt; 0},1
  7      EXE_FILES         =&gt; [ 'scripts/tutu.pl', 'scripts/tutu' ],
  8      ($] &gt;= 5.005 ?     ## Add these new keywords supported since 5.005
  9        (ABSTRACT_FROM  =&gt; 'lib/PL/Tutu.pm', # retrieve abstract from module
 10         AUTHOR         =&gt; 'Casiano Rodriguez Leon &lt;casiano@ull.es&gt;') : ()),
 11  );
</PRE>
Se actualiza también MANIFEST:
<PRE>
$ cat -n MANIFEST
 1  Changes
 2  lib/PL/Error.pm
 3  lib/PL/Lexical/Analysis.pm
 4  lib/PL/Syntax/Analysis.pm
 5  lib/PL/Tutu.pm
 6  Makefile.PL
 7  MANIFEST
 8  MANIFEST.SKIP
 9  README
10  scripts/test01.tutu
11  scripts/tutu
12  scripts/tutu.pl
13  t/01Lexical.t
</PRE>

<P>
Ahora <code>compile</code> llama a <code>Syntax::Analysis::parser</code> pasándole
como argumento la lista de terminales <code>@tokens</code>. La función <code>parser</code>
devuelve el AAA:
<PRE>
04sintactico/PL-Tutu/lib/PL$ sed -ne '/sub compile\&gt;/,/^}/p' Tutu.pm | cat -n
  1  sub compile {
  2    my ($input) = @_;
  3    #my %symbol_table = ();
  4    #my $data = ""; # Contiene todas las cadenas en el programa fuente
  5    my $target = ""; # target code
  6    my @tokens = ();
  7    my $tree = undef; # abstract syntax tree
  8    #my $global_address = 0;
  9
 10
 11    ########lexical analysis
 12    @tokens = scanner($input);
 13    #print "@tokens\n";
 14
 15    ########syntax (and semantic) analysis
 16    $tree = &amp;Syntax::Analysis::parser(@tokens);
 17    print Dumper($tree);
 18
 19    ########machine independent optimizations
 20    &amp;Machine::Independent::Optimization::Optimize;
 21
 22    ########code generation
 23    &amp;Code::Generation::code_generator;
 24
 25    ########peephole optimization
 26    &amp;Peephole::Optimization::transform($target);
 27
 28    return \$target;
 29  }
</PRE>
El módulo <code>Class::MakeMethods::Emulator::MethodMaker</code>
permite crear constructores y métodos de acceso.
El módulo no viene con la distribución de Perl, así que, en general, deberá 
descargarlo desde CPAN e instalarlo.
Así definimos que existe una clase de nodos <code>TYPE</code>
que nuestro AAA va a tener:

<P>
<PRE>
package TYPE;
make methods
  get_set       =&gt; [ 'NAME', 'LENGTH' ],
  new_hash_init =&gt; 'new';
</PRE>

<P>
El uso de los argumentos <code>get_set =&gt; [ 'NAME', 'LENGTH' ]</code>
hace que se cree un objeto de tipo hash  con claves 
<code>'NAME'</code> y <code>'LENGTH'</code> así como métodos <code>NAME</code>
y <code>LENGTH</code> que cuando se llaman con un argumento devuelven
el valor y cuando se llaman con dos argumentos modifican el
valor correspondiente. 
La clave <code>get_set</code> produce métodos de acceso
y modificación de los atributos del objeto que
tienen la forma:

<P>
<PRE>
sub TYPE::NAME {
  my ($self, $new) = @_;
  defined($new) and $self-&gt;{NAME} = $new;
  return $self-&gt;{NAME};
}
</PRE>

<P>
Asi mismo el uso de <code>new_hash_init =&gt; 'new'</code>
genera un constructor cuyo nombre
será <code>'new'</code> y que cuando es llamado inicializará el
objeto con los argumentos con nombre especificados en la llamada.
El constructor construído (vaya retruécano) cuando se usa la clave
<code>new_hash_init</code> tiene el siguiente aspecto:

<P>
<PRE>
sub TYPE::new {
  my ($class, %args) = @_;
  my $self = {};

  bless $self, $class;
  foreach my $attribute (keys %args) {
    $self-&gt;$attribute($args{$attribute});
  }
  return $self;
}
</PRE>

<P>
Ahora podemos crear objetos de la clase <code>TYPE</code> haciendo:
<PRE>
my $int_type = TYPE-&gt;new(NAME =&gt; 'INTEGER', LENGTH =&gt; 1); 
my $string_type = TYPE-&gt;new(NAME =&gt; 'STRING', LENGTH =&gt; 2);
my $err_type = TYPE-&gt;new(NAME =&gt; 'ERROR', LENGTH =&gt; 0);
</PRE>
Cada uno de estos objetos es un hash con las correspondientes
claves para el nombre y el tipo.

<P>
Otros tipos de nodos del AAA son:

<P>
<PRE>
package PROGRAM; # raíz del AAA
make methods
  get_set       =&gt; [ 'DECLS', 'STS' ],
  new_hash_init =&gt; 'new';

package STRING; # tipo
make methods
  get_set       =&gt; [ 'TYPE', 'IDLIST' ],
  new_hash_init =&gt; 'new';

package INT; # tipo
make methods
  get_set       =&gt; [ 'TYPE', 'IDLIST' ],
  new_hash_init =&gt; 'new';

package ASSIGN; #sentencia
make methods
  get_set       =&gt; [ 'LEFT', 'RIGHT' ],
  new_hash_init =&gt; 'new';

package PRINT; #sentencia
make methods
  get_set       =&gt; [ 'EXPRESSION' ],
  new_hash_init =&gt; 'new';

package NUM; # para los números
make methods
  get_set       =&gt; [ 'VAL', 'TYPE' ],
  new_hash_init =&gt; 'new';

package ID; # Nodos identificador. Parte derecha
make methods
  get_set       =&gt; [ 'VAL', 'TYPE' ],
  new_hash_init =&gt; 'new';

package STR; # Clase para las constantes cadena
make methods
  get_set       =&gt; [ 'OFFSET', 'LENGTH', 'TYPE' ],
  new_hash_init =&gt; 'new';

package PLUS; # Nodo suma
make methods
  get_set       =&gt; [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init =&gt; 'new';

package TIMES;
make methods
  get_set       =&gt; [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init =&gt; 'new';

package LEFTVALUE; # Identificador en la parte izquierda
make methods       # de una asignación
  get_set       =&gt; [ 'VAL', 'TYPE' ],
  new_hash_init =&gt; 'new';
</PRE>

<P>
Hemos extendido el concepto de gramática 
árbol con el concepto de <A NAME="10093"></A><B>lista de no terminales</B>. 
A la hora de construir las estructuras de datos
las listas de variables se van a traducir por listas de árboles.
Los tipos de nodos (<IMG
 WIDTH="80" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img225.png"
 ALT="$ ASSIGN$">
, <IMG
 WIDTH="69" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img255.png"
 ALT="$ PRINT$">
, ...)
se traducen en nombres de clases. Hemos hecho
una excepción con <IMG
 WIDTH="108" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img254.png"
 ALT="$ SIMPLEID$">
 el cual es simplemente una 
variable cadena conteniendo el identificador correspondiente.

<P>
El siguiente esquema de traducción resume la idea para una gramática 
simplificada: cada vez que encontremos un nodo en el árbol sintáctico 
concreto con una operación crearemos un nodo en el AAA cuya clase
viene definida por el tipo de operación. Para los terminales
creamos igualmente nodos indicando de que clase de terminal 
se trata. El atributo nodo lo denotaremos por <code>n</code>:

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><!-- MATH
 $e   \rightarrow\ e_1 + f$
 -->
<IMG
 WIDTH="93" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img256.png"
 ALT="$ e \rightarrow e_1 + f$">
</TD>
<TD ALIGN="LEFT"><code>{ $e{n} = PLUS-&gt;new(LEFT=&gt;$e_1{n}, RIGHT=&gt;$f{n}) }</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $f   \rightarrow NUM$
 -->
<IMG
 WIDTH="91" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img257.png"
 ALT="$ f \rightarrow NUM$">
</TD>
<TD ALIGN="LEFT"><code>{ $f{n} = NUM-&gt;new(VAL =&gt; $NUM{VAL}) }</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $f   \rightarrow ID$
 -->
<IMG
 WIDTH="66" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img258.png"
 ALT="$ f \rightarrow ID$">
</TD>
<TD ALIGN="LEFT"><code>{ $f{n} = ID-&gt;new(VAL =&gt; $ID{VAL}) }</code></TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
La estructura de cada rutina sigue siendo la misma, 
sólo que ampliada con las acciones para la construcción de los
correspondientes nodos. Veamos por ejemplo, como modificamos
la subrutina factor:

<P>
<PRE>
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') {
    $num = $value;
    match('NUM');
    return NUM-&gt;new(VAL =&gt; $num, TYPE =&gt; $int_type);
  }
  elsif ($lookahead eq 'ID') {
    $id = $value;
    match('ID');
    return ID-&gt;new( VAL =&gt; $id, TYPE =&gt; undef);
  }
  elsif ($lookahead eq 'STR') {
    $str = $value;
    match('STR');
    return STR-&gt;new(OFFSET =&gt; undef, LENGTH =&gt; undef, TYPE =&gt; $string_type);
  }
  elsif ($lookahead eq '(') {
    match('(');
    $e = expression;
    match(')');
    return $e;
  }
  else {
    Error::fatal("Se esperaba (, NUM o ID");
  }
}
</PRE>

<P>
<HR>
<A NAME="tex2html3621"
  HREF="node150.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3615"
  HREF="node147.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3609"
  HREF="node148.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3617"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3619"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3622"
  HREF="node150.html">AAA: Otros tipos de</A>
<B>Sup:</B> <A NAME="tex2html3616"
  HREF="node147.html">Árbol de Análisis Abstracto</A>
<B> Ant:</B> <A NAME="tex2html3610"
  HREF="node148.html">Lenguajes Árbol y Gramáticas</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
