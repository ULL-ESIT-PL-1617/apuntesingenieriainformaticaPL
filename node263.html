<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Esquemas de Traducción con Parse::Eyapp</TITLE>
<META NAME="description" CONTENT="Esquemas de Traducción con Parse::Eyapp">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node264.html">
<LINK REL="previous" HREF="node262.html">
<LINK REL="up" HREF="node261.html">
<LINK REL="next" HREF="node264.html">
</HEAD>

<BODY >

<A NAME="tex2html5392"
  HREF="node264.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html5386"
  HREF="node261.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html5380"
  HREF="node262.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html5388"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html5390"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html5393"
  HREF="node264.html">Definición Dirigida por la</A>
<B>Sup:</B> <A NAME="tex2html5387"
  HREF="node261.html">Análisis Semántico con Parse::Eyapp</A>
<B> Ant:</B> <A NAME="tex2html5381"
  HREF="node262.html">Esquemas de Traducción: Conceptos</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->

<H1><A NAME="SECTION001420000000000000000"></A>
<A NAME="section:eyappeyappts"></A>
<BR>
Esquemas de Traducción con <TT>Parse::Eyapp</TT>
</H1>
La distribución  Parse::Eyapp  debida al autor de estos apuntes (i.e. Casiano Rodriguez-Leon)
permite la escritura de esquemas de traducción. El módulo no esta aún disponible
en CPAN: estoy a la espera de completar las pruebas y la documentación.

<P>
El ejemplo simple que sigue ilustra como construir un esquema de traducción. 
El código completo puede encontrarlo en la página
<A HREF="#apendice:transschemesimple"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.
Un ejemplo de ejecución del programa se encuentra en la página 
<A HREF="#apendice:ejecuciondetrans_scheme_simple"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.

<P>
Comencemos por el principio:
<A NAME="codigo:eyapptrans_scheme_simple2"></A><PRE>
nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; head -n79 trans_scheme_simple2.pl | cat -n
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Data::Dumper;
 4  use Parse::Eyapp;
 5  use IO::Interactive qw(is_interactive);
 6
 7  my $translationscheme = q{
 8  %{
 9  # head code is available at tree construction time
10  use Data::Dumper;
11
12  our %sym; # symbol table
13  %}
14
15  %metatree
16
17  %right   '='
18  %left   '-' '+'
19  %left   '*' '/'
20
21  %%
22  line:       %name EXP
23                exp &lt;+ ';'&gt; /* Expressions separated by semicolons */
24                  { $lhs-&gt;{n} = [ map { $_-&gt;{n}} $_[1]-&gt;Children() ]; }
25  ;
26
27  exp:
28              %name PLUS
29                exp.left '+'  exp.right
30                  { $lhs-&gt;{n} = $left-&gt;{n} + $right-&gt;{n} }
31          |   %name MINUS
32                exp.left '-' exp.right
33                  { $lhs-&gt;{n} = $left-&gt;{n} - $right-&gt;{n} }
34          |   %name TIMES
35                exp.left '*' exp.right
36                  { $lhs-&gt;{n} = $left-&gt;{n} * $right-&gt;{n} }
37          |   %name DIV
38                exp.left '/' exp.right
39                  { $lhs-&gt;{n} = $left-&gt;{n} / $right-&gt;{n} }
40          |   %name NUM   $NUM
41                  { $lhs-&gt;{n} = $NUM-&gt;{attr} }
42          |   '(' $exp ')'  %begin { $exp }
43          |   %name VAR
44                $VAR
45                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} }
46          |   %name ASSIGN
47                $VAR '=' $exp
48                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
49
50  ;
51
52  %%
53  # tail code is available at tree construction time
54  sub _Error {
55    my($token)=$_[0]-&gt;YYCurval;
56    my($what)= $token ? "input: '$token'" : "end of input";
57
58    die "Syntax error near $what.\n";
59  }
60
61  sub _Lexer {
62      my($parser)=shift;
63
64      for ($parser-&gt;YYData-&gt;{INPUT}) {
65          $_ or  return('',undef);
66
67          s/^\s*//;
68          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
69          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
70          s/^(.)// and return($1,$1);
71          s/^\s*//;
72      }
73  }
74
75  sub Run {
76      my($self)=shift;
77      return $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error );
78  }
79  }; # end translation scheme
</PRE>

<P>
Las líneas 7-79 no hacen otra cosa que iniciar una cadena conteniendo el esquema de
traducción. También podríamos haberlo escrito en un fichero y compilarlo con 
 eyapp . 

<P>

<H4><A NAME="SECTION001420010000000000000">
Partes de un programa <TT>eyapp</TT></A>
</H4>
  

<P>
Un programa <code>eyapp</code> es similar en muchos aspectos a 
un programa  eyapp / yacc  y se divide en tres partes:
la cabeza, el cuerpo
y la cola. Cada una de las partes va separada de las otras por el
símbolo <code>%%</code> en una línea aparte. Así, el <code>%%</code> de la línea 21
separa la cabeza del cuerpo. En la cabecera se colocan el
código de inicialización, las declaraciones de terminales, las reglas
de precedencia, etc.  El cuerpo contiene las reglas de la gramática y
las acciones asociadas. Por último, la cola de un program <code>eyapp</code>
se separa del cuerpo por otro <code>%%</code> en una línea aparte.
La cola contiene las rutinas de soporte al código que aparece en las acciones 
asi como, posiblemente, rutinas para el análisis léxico  (subrutina <code>_Lexer</code>
en la línea 58)
y el tratamiento de errores (subrutina <code>_Error</code> en la línea 54).
Puede encontrar una descripción de la gramática de <code>eyapp</code> 
usando su propia notación en la página
<A HREF="#apendice:eyappgrammar"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.

<P>

<H4><A NAME="SECTION001420020000000000000">
Esquemas de Traducción con <TT>%metatree</TT></A>
</H4>
  

<P>
Por defecto <code>Parse::Eyapp</code> se comporta de manera similar a <code>eyapp</code>
y <code>yacc</code> generando un analizador sintáctico LALR(1) y ejecutando 
las acciones empotradas según una antiderivación a derechas, esto es en un
recorrido del árbol de análisis sintáctico 
de abajo hacia arriba y de izquierda a derecha. 

<P>
Mediante la directiva  %metatree  en la línea 15 
le indicamos a <code>Parse::Eyapp</code> que debe generar un 
esquema de traducción. En tal caso, al llamar al analizador
el código empotrado no es ejecutado sino que se genera un árbol
de análisis sintáctico con los correspondientes nodos de código
colgando del árbol en las posiciones que les corresponden.

<P>

<H4><A NAME="SECTION001420030000000000000">
Las reglas</A>
</H4>
  

<P>
Las reglas de producción de la gramática están entre 
las líneas 21 y 52. Cada entrada comienza con el nombre de la variable sintáctica
y va seguida de las partes derechas de sus reglas de producción separadas por barras
verticales. Opcionalmente se le puede dar un nombre a la regla de producción
usando la directiva  %name . El efecto que tiene esta directiva 
es bendecir - durante la fase tree construction time - 
el nodo del árbol sintáctico en una clase con nombre el
argumento de <code>%name</code> (los nodos del árbol sintáctico son objetos).
El código - entre llaves - puede ocupar cualquier lugar en el lado
derecho. 

<P>

<H4><A NAME="SECTION001420040000000000000">
Nombres de los atributos</A>
</H4>
  

<P>
En las acciones los atributos de los nodos pueden ser accedidos usando 
el array mágico <code>@_</code>. De hecho, los códigos insertados en el árbol
sintáctico son convertidos en subrutinas anónimas. 
Así <code>$_[0]</code> es una referencia al nodo 
padre asociado con el lado izquierdo, <code>$_[1]</code> el asociado
con el primer símbolo de la parte derecha, etc. <I>Esta <A NAME="21413"></A><B>notación posicional</B>
es confusa e induce a error: si el programador cambia la regla posteriormente insertando
acciones o símbolos en la parte derecha, ¡todas las apariciones de índices en
el código que se refieran a nodos a la derecha del insertado
deben ser modificadas!</I>. Algo similar ocurre si decide suprimir una acción o un 
símbolo. Por ello <code>Parse::Eyapp</code> 
proporciona mediante la <A NAME="21415"></A><B>notación punto</B> la posibilidad de
hacer una copia automática con nombre del atributo: la notación
<code>exp.left</code> indica que la variable léxica <code>$left</code>
guardará una referencia al nodo que corresponde a esta instanciación de la variable
sintáctica <code>exp</code>. Además <code>Parse::Eyapp</code> provee la variable
léxica especial <code>$</code> lhs  donde se guarda una referencia al nodo padre.
Así la regla:

<P>
<PRE>
                exp.left '-' exp.right
                  { $lhs-&gt;{n} = $left-&gt;{n} - $right-&gt;{n} }
</PRE>
equivale al siguiente código:
<PRE>
                 exp '-' exp
                  { 
                    my $lhs = shift; 
                    my ($left, $right) = @_[1, 3];
                    $lhs-&gt;{n} = $left-&gt;{n} - $right-&gt;{n} 
                  }
</PRE>
Si se desea usar el propio nombre de la variable sintáctica como 
nombre del atributo se usa la <A NAME="21417"></A><B>notación dolar</B>. Asi la notación
<code>$exp</code> puede considerarse una abreviación a la notación <code>exp.exp</code>. 
El código:
<PRE>
                $VAR '=' $exp
                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
</PRE>
equivale a este otro:
<PRE>
                  VAR '=' exp
                  { 
                    my $lhs = shift;
                    my ($VAR, $exp) = @_[1, 3];
                    $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} 
                  }
</PRE>

<P>

<H4><A NAME="SECTION001420050000000000000">
Nombres de atributos de expresiones complejas Eyapp</A>
</H4>
  

<P>
Consideremos la parte derecha de la regla de producción:

<P>
<code>program: definition&lt;%name PROGRAM +&gt;.program</code>

<P>
observe los siguientes detalles:

<P>

<OL>
<LI>Es posible usar los símbolos menor/mayor para incidir en el hecho de que la especificación
del tipo del nodo construido como nodo <code>PROGRAM</code> se le da a la lista no vacía 
de repeticiones de <code>definition</code>. 
Funciona como un paréntesis de agrupamiento y es opcional. Podríamos haber escrito:

<P>
<code>program: definition %name PROGRAM +.program</code>

<P>
pero es, sin duda, mas confuso para el lector.

<P>
</LI>
<LI>Si queremos darle nombre al nodo asociado con el único elemento en la parte derecha
de la regla:

<P>
<code>program: definition %name PROGRAM +.program</code>

<P>
no podemos usar la <A NAME="21423"></A><B>notación dolar</B>. Este código que pretende ser equivalente al anterior:
<PRE>
program:
    $definition&lt;%name PROGRAM +&gt;
</PRE>
produce un mensaje de error:
<PRE>
nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; eyapp Simple4
*Fatal* $ is allowed for identifiers only (Use dot notation instead), at line 149 at file Simple4.eyp
</PRE>
La razón del mensaje es doble:

<P>

<UL>
<LI>Primero: se esta intentando dar un nombre singular <code>definition</code> a 
algo que es una lista y por tanto plural: debería ser algo parecido a
<code>definitions</code>. La decisión del programador es inadecuada.

<P>
</LI>
<LI>Segundo: Los operadores de lista tiene mayor prioridad que el dolar:
la expresión <code>$definition&lt;%name PROGRAM +&gt;</code> es interpretada
como <code>$(definition&lt;%name PROGRAM +&gt;)</code>. El dolar esta actuando sobre 
la expresión compuesta <code>definition&lt;%name PROGRAM +&gt;</code> que no es un identificador.
</LI>
</UL>

<P>
La solucion:
<B>En vez del dolar deberemos usar la <A NAME="21425"></A><B>notación punto</B> para darle
nombre al atributo, como se ha hecho en el ejemplo</B>.
</LI>
</OL>

<P>

<H4><A NAME="SECTION001420060000000000000">
Fases de un Esquema de Traducción</A>
</H4>
  

<P>
La ejecución de un esquema de traducción por <code>Parse::Eyapp</code> 
ocurre en tres tiempos. 

<P>

<H4><A NAME="SECTION001420070000000000000">
Class Construction Time</A>
</H4>
  

<P>
En una primera parte - que denominaremos
<A NAME="21435"></A><B>Class Construction Time</B> - se analiza la gramática y se crea 
la clase que contendrá el analizador sintáctico. 
Esto se hace llamando al método de clase  new_grammar 
el cual devuelve una cadena conteniendo información
sobre las ambiguedades, conflictos y errores
que pueda tener la gramática:

<P>
<PRE>
84  my $warnings = Parse::Eyapp-&gt;new_grammar(
85    input=&gt;$translationscheme,
86    classname=&gt;'main',
87    firstline =&gt; 6,
88    outputfile =&gt; 'main.pm');
89  die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;
</PRE>

<P>
El nombre de la clase  o package en el que se crea el analizador
se especifica mediante el argumento  classname .

<P>
El argumento  firstline  facilita la emisión de errores 
y warnings indicando la línea en que comienza la cadena que contiene
el esquema de traducción.

<P>
Si se especifica el argumento  outputfile <code> =&gt; filename</code> los resultados
del análisis se volcarán en los ficheros <code>filename.pm</code> y <code>filename.output</code>
los cuales contienen respectivamente el código del analizador e información
pormenorizada sobre las tablas usadas por el analizador y los conflictos
y ambiguedades encontradas durante el estudio de la gramática.

<P>
Una vez creada la clase es posible instanciar objetos del tipo analizador
llamando al constructor <code>new</code> de la clase creada:

<P>
<PRE>
90  my $parser = main-&gt;new();
</PRE>

<P>

<H4><A NAME="SECTION001420080000000000000">
Tree Construction Time</A>
</H4>
  

<P>
En una segunda parte - que denominaremos 
<A NAME="21441"></A><B>Tree Construction Time</B> - se toma la entrada (usando para ello el analizador 
léxico y las rutinas de error proveídas por el programador) 
y se procede a la construcción del árbol. 
<B>Las acciones
especificadas por el programador en el esquema no son ejecutadas</B> sino
que se añaden al árbol como referencias a subrutinas (nodos de tipo <code>CODE</code>). 

<P>
El programador
puede influir en la construcción del árbol por medio de diversas directivas.
De estas explicaremos tres:

<P>

<H4><A NAME="SECTION001420090000000000000">
La directiva <TT>%name class</TT></A>
</H4>
  

<P>
Como se ha dicho, la directiva <code>%name class</code> hace que el nodo asociado con la 
instanciación  de la regla de producción se bendiga en la clase dada por la cadena
<code>class</code>. 

<P>

<H4><A NAME="SECTION0014200100000000000000">
La directiva <TT>%begin</TT></A>
</H4>
  

<P>
La directiva  %begin  <code>{ ... code ...}</code> usada en la línea 42 hace que el
código usado como argumento <code>{ ... code ...}</code> se ejecute en <I>Tree Construction Time</I>.
<PRE>
27  exp:
28              %name PLUS
29                exp.left '+'  exp.right
30                  { $lhs-&gt;{n} = $left-&gt;{n} + $right-&gt;{n} }
31          |   %name MINUS
..          .   ............................................
42          |   '(' $exp ')'  %begin { $exp }
</PRE>

<P>
En el ejemplo la directiva <code>%begin { $exp }</code> hace que nos saltemos
el nodo asociado con el paréntesis enlazando directamente la raíz del árbol
referenciado por <code>$exp</code> con el padre de la regla actual.
Si no se hubiera insertado esta directiva el árbol construido para
la entrada <code>2*(3+4)</code> sería similar a este:
<PRE>
TIMES
  |-- NUM -- TERMINAL( attr =&gt; 2 )
  |-- '*'
  `-- E_7
       |-- '('
       |-- PLUS
       |    |-- NUM -- TERMINAL( attr =&gt; 3 )
       |    |-- '+'
       |    `-- NUM -- TERMINAL( attr =&gt; 4 )
       `--  ')'
</PRE>
El efecto de la directiva <code>%begin { $exp }</code> es retornar la referencia
a la expresión parentizada dando lugar al siguiente árbol:
<PRE>
TIMES
  |-- NUM -- TERMINAL( attr =&gt; 2 )
  |-- '*'
  `-- PLUS
       |-- NUM -- TERMINAL( attr =&gt; 3 )
       |-- '+'
       `-- NUM -- TERMINAL( attr =&gt; 4 )
</PRE>

<P>
En general, 
las acciones asociadas con directivas <code>%begin</code> 
modifican la construcción del árbol sintáctico
concreto para dar lugar a un árbol de análisis sintáctico abstracto adecuado
a los requerimientos de las fases posteriores. 

<P>
Las acciones en Tree Construction Time insertadas mediante <code>%begin</code>
se ejecutan colaborativamente con las acciones de construcción del árbol 
en el orden 
usual de los analizadores LR: según una antiderivación a derechas, 
esto es, en un
recorrido del árbol de análisis sintáctico 
de abajo hacia arriba (de las hojas hacia la raíz) y de izquierda a derecha. 

<P>
Las acciones en Tree Construction Time
reciben como argumentos en <code>$_[1]</code>, <code>$_[2]</code>, etc. las referencias a los
nodos del árbol asociadas con los elementos de la parte derecha. 
<I>En Tree Construction Time el argumento <code>$_[0]</code>
es una referencia al objeto analizador sintáctico</I>.

<P>
La segunda fase en nuestro ejemplo ocurre en las líneas 90-92
en las que leemos la entrada y llamamos al método 
<code>Run</code> el cual construye el árbol:

<P>
<PRE>
90  print "Write a sequence of arithmetic expressions: " if is_interactive();
91  $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
92  my $t = $parser-&gt;Run() or die "Syntax Error analyzing input";
</PRE>

<P>
El método <code>Run</code> se limita a llamar al método <code>YYParse</code> que es quien 
realiza el análisis:

<P>
<PRE>
74  sub Run {
75      my($self)=shift;
76      return $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error );
77  }
</PRE>

<P>
Cuando el método <code>YYParse</code> proveido por <code>Parse::Eyapp</code> es llamado
es necesario que hayan sido especificadas las correspondientes 
referencias a las rutinas de análisis léxico
(argumento con clave <code>yylex</code>) 
y de tratamiento de errores (argumento con clave <code>yyerror</code>).

<P>
Despues de esta fase tenemos el árbol de análisis extendido con los
nodos de tipo <code>CODE</code>.

<P>

<H4><A NAME="SECTION0014200110000000000000">
Execution Time</A>
</H4>
  

<P>
En una tercera parte - que denominaremos <A NAME="21457"></A><B>Execution Time</B> - el árbol es recorrido
en orden primero-profundo y los nodos de la clase <code>CODE</code> son ejecutados. El
árbol será modificado y decorado como consecuencia de las acciones
y podremos examinar los resultados:
<PRE>
93  $t-&gt;translation_scheme;
94  my $treestring = Dumper($t);
95  our %sym;
96  my $symboltable = Dumper(\%sym);
97  print &lt;&lt;"EOR";
98  ***********Tree*************
99  $treestring
100  ******Symbol table**********
101  $symboltable
102  ************Result**********
103  $t-&gt;{n}
104
105  EOR
</PRE>

<P>
El método <code>translation_scheme</code> tiene una estructura simple
y tiene un código similar a este:

<P>
<PRE>
sub translation_scheme {
  my $self = shift; # root of the subtree
  my @children = $self-&gt;children();
  for (@children) {
    if (ref($_) eq 'CODE') {
      $_-&gt;($self, @children);
    }
    elsif (defined($_)) {
      translation_scheme($_);
    }
  }
}
</PRE>
Como se ve en el código de <code>translation_scheme</code> la subrutina
asociada se le pasan como argumentos referencias al nodo y a los hijos del nodo.

<P>

<H4><A NAME="SECTION0014200120000000000000">
Los Terminales</A>
</H4>
  

<P>
Durante la fase de construcción del árbol sintáctico
los nodos que corresponden a terminales o tokens de la gramática 
son -por defecto - bendecidos en la clase <code>"${PREFIX}</code> TERMINAL <code>"</code>.
Si el programador no ha indicado lo contrario en la llamada al analizador,
<code>$PREFIX</code> es la cadena vacía. 
(Véase el párrafo en la página <A HREF="node263.html#paragraph:eyappprefix"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> sobre el argumento <code>yyprefix</code>
del método constructor del analizador).

<P>
Los nodos de la clase <code>TERMINAL</code> poseen 
al menos dos atributos <code>token</code> y <code>attr</code>. El atributo 
<code>token</code> indica que clase de terminal es (<code>NUM</code>, <code>IDENTIFIER</code>, etc.).
El atributo <code>attr</code> nos da el valor semántico del terminal tal y como
fué recibido del analizador léxico.

<P>

<H4><A NAME="SECTION0014200130000000000000">
Listas y Opcionales</A>
</H4>
  

El fragmento del esquema de traducción entre las líneas 26 y 30:

<P>
<PRE>
26  line: %name PROG
27         exp &lt;%name EXP + ';'&gt;
28           { @{$lhs-&gt;{t}} = map { $_-&gt;{t}} ($lhs-&gt;child(0)-&gt;Children()); }
29
30  ;
</PRE>

<P>
expresa que el lenguaje generado por el no terminal <code>line</code> esta formado por
secuencias no vacías de frases generadas a partir de <code>exp</code> separadas por
puntos y comas. En concreto, el analizador generado por <code>eyapp</code> transforma
la regla <code>line: exp &lt;%name EXP + ';'&gt;</code> en:
<PRE>
line:       %name EXP
              PLUS-1
;
PLUS-1:     %name _PLUS_LIST
              PLUS-1 ';'  exp
        |     exp      
;
</PRE>

<P>
La expresión <code>exp &lt;+ ';'&gt;</code> es tratada como un único elemento de la parte 
derecha y su atributo es un nodo de la clase  _PLUS_LIST  cuyos
hijos son los elementos de la lista. Por ejemplo, para la entrada
<code>a=2; b = 2*a</code> el analizador construye un árbol similar a este:
<PRE>
bless( {
  'children' =&gt; [
    bless( {              # _PLUS_LIST
    | 'children' =&gt; [
    |   bless( {          # ASSIGN a = 2
    |   | 'children' =&gt; [
    |   |   bless( { 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   bless( { 'attr' =&gt; '=', 'token' =&gt; '=' }, 'TERMINAL' ),
    |   |   bless( {      # NUM 2
    |   |     'children' =&gt; [
    |   |       bless( { 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'TERMINAL' ),
    |   |       sub { my $lhs = $_[0]; my $NUM = $_[1];  $lhs-&gt;{n} = $NUM-&gt;{attr}  }
    |   |     ]
    |   |   }, 'NUM' ),
    |   |   sub { my ($lhs, $exp, $VAR) = ($_[0], $_[3], $_[1]);  
    |   |         $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n}  }
    |   | ]
    |   }, 'ASSIGN' ),
    |   bless( {         # ASSIGN b = 2*a
    |   | 'children' =&gt; [
    |   |   bless( { 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   bless( { 'attr' =&gt; '=', 'token' =&gt; '=' }, 'TERMINAL' ),
    |   |   bless( {     # TIMES 2*a
    |   |     'children' =&gt; [
    |   |       bless( { .... }, 'NUM' ),
    |   |       bless( { 'attr' =&gt; '*', 'token' =&gt; '*' }, 'TERMINAL' ),
    |   |       bless( { .... }, 'VAR' ),
    |   |       sub { ... }
    |   |     ]
    |   |   }, 'TIMES' ),
    |   |   sub { ... }
    |   | ]
    |   }, 'ASSIGN' )
    | ]
    }, '_PLUS_LIST' ),
    sub { ... }
  ]
}, 'EXP' )
</PRE>

<P>
<B>Observe que, por defecto, los nodos punto y coma (<TT>;</TT>) son eliminados del nodo
lista de hijos del nodo</B> <code>_PLUS_LIST</code>. Por defecto, en los
nodos creados por <code>Parse::Eyapp</code> desde listas 
declaradas mediante operadores de brackets (por ejemplo <code>St &lt;+ ';'&gt;</code>
o <code>ID &lt;* ','&gt;</code>) se 
elimina el separador si este fué definido mediante una cadena (uso de apostrofes).

<P>
Diremos que un terminal es un <A NAME="21467"></A><B>terminal sintáctico</B> o
<A NAME="21469"></A><B>syntax token</B> si fue definido en el programa <code>eyapp</code>
mediante una cadena delimitada por
apóstrofes.

<P>
Si queremos cambiar el estatus de un syntax token, por ejemplo
si queremos 
que el separador <code>';'</code> del ejemplo forme parte de la lista deberemos añadir a la cabecera
la declaración <code>%semantic token ';'</code>. 

<P>
Si creamos una nueva versión
de nuestro programa <code>trans_scheme_simple3.pl</code> añadiendo esta declaración:

<P>
<PRE>
%semantic token ';'
%right   '='
....
</PRE>
Las listas contendran los puntos y comas. 
En tal caso, la línea 24 dará lugar a un 
error<A NAME="tex2html265"
  HREF="footnode.html#foot21350"><SUP>9.1</SUP></A>ya que los nodos 
punto y coma carecen del atributo <code>n</code>:
<PRE>
24                  { $lhs-&gt;{n} = [ map { $_-&gt;{n}} $_[1]-&gt;Children() ]; }
</PRE>

<P>
En efecto:

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; trans_scheme_simple3.pl &gt; salida
a=2*3; b = a+1; c = a-b
Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, &lt;&gt; line 1.
Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, &lt;&gt; line 1.
</PRE>
Al usar la declaración  %semantic token  la nueva estructura del árbol es:
<PRE>
bless( {
  'n' =&gt; [ 6, undef, 7, undef, -1 ],
  'children' =&gt; [
    bless( {
      'children' =&gt; [
        bless( { 'n' =&gt; 6, ................  ] }, 'ASSIGN' ),
        bless( { 'children' =&gt; [], 'attr' =&gt; ';', 'token' =&gt; ';' }, 'TERMINAL' ),
        bless( { 'n' =&gt; 7, ................  }, 'ASSIGN' ),
        bless( { 'children' =&gt; [], 'attr' =&gt; ';', 'token' =&gt; ';' }, 'TERMINAL' ),
        bless( { 'n' =&gt; -1, ................  }, 'ASSIGN' )
      ]
    }, '_PLUS_LIST' ),
    sub { "DUMMY" }
  ]
}, 'EXP' )
</PRE>
<code>Parse::Eyapp</code> extiende  Parse::Yapp  con listas vacías y no vacías
usando los operadores <code>*</code>, <code>+</code>:

<P>
La regla:
<PRE>
                          A : B C * 'd'
</PRE>
es equivalente a:

<P>
<PRE>
                          A : B L 'd' 
                          L : /* vacío */
                            | P
                          P : C P
                            | C
</PRE>

<P>
Es posible especificar la presencia de símbolos
opcionales usando <code>?</code>. 

<P>
Observe que el operador de concatenación tiene menor prioridad que 
los operadores de listas, esto es la expresión <code>AB*</code> es interpretada
como <code>A(B*)</code>.

<P>
Una secuencia de 
símbolos en la parte derecha de una regla de producción
puede ser agrupada mediante el uso de paréntesis.
Al agrupar una secuencia se crea una variable sintáctica intermedia
que produce dicha secuencia. Por ejemplo, la regla:

<P>
<PRE>
                    A : B (C { dosomething(@_) })? D
</PRE>

<P>
es equivalente a:
<PRE>
                    A  : B T1 D 
                    T1 :  /* vacío */
                       | T2
                    T2 : C { dosomething(@_) }
</PRE>

<P>

<H4><A NAME="SECTION0014200140000000000000">
Ambiguedades</A>
</H4>
  

<P>
Hay numerosas ambiguedades en la gramática asociada con el
esquema de traducción presentado en la página 
<A HREF="#codigo:trans_scheme_simple2"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.
Las ambiguedades se resuelven exactamente igual
que en <code>yacc</code> usando directivas en la <A NAME="21475"></A><B>cabecera</B> o
primera parte que indiquen como resolverlas. 

<P>
Entre las ambiguedades presentes en la gramática del ejemplo
estan las siguientes:

<P>

<UL>
<LI>¿Como debo interpretar la expresión <code>e - e - e</code>?
¿Como <code>(e - e) - e</code>? ¿o bien <code>e - (e - e)</code>?
La respuesta la da la asignación de asociatividad a los operadores
que hicimos en la cabecera.
Al declarar como asociativo a izquierdas al terminal <code>-</code> 
hemos resuelto este tipo de ambiguedad. Lo que estamos haciendo es
indicarle al analizador que a la hora de elegir entre 
los árboles abstractos elija siempre el árbol que se hunde a izquierdas.
</LI>
<LI>¿Como debo interpretar la expresión <code>e - e * e</code>?
¿Como <code>(e - e) * e</code>? ¿o bien <code>e - (e * e)</code>?

<P>
En <code>eyapp</code> los terminales declarados mediante directivas
<code>%left</code>, <code>%right</code> y <code>%nonassoc</code>
tienen asociada <U>una prioridad</U>. <B>Esa prioridad es 
mayor cuanto mas abajo en el texto está la línea 
de su declaración</B>. 
Un terminal puede ser también declarado con la directiva <code>%token</code> en
cuyo caso no se le asocia prioridad.

<P>
Al declarar que el operador <code>*</code> tiene mayor prioridad que el operador <code>-</code> 
estamos resolviendo esta otra fuente de ambiguedad. Esto es así pues
el operador <code>*</code> fué declarado después que el operador <code>-</code>.
Le indicamos así al analizador que construya el árbol asociado con
la interpretación <code>e - (e * e)</code>.

<P>
<B>En <TT>eyapp</TT> La prioridad asociada con una regla de producción
es la del <U>último terminal</U> que aparece en dicha regla</B>.

<P>
Una regla de producción puede ir seguida de una directiva
 %prec  la cual le da una prioridad explícita.  
Esto puede ser de gran ayuda en ciertos casos de 
ambiguedad.
Por ejemplo, si quisieramos introducir el uso el menos unario en
la gramática surgiría una ambiguedad:

<P>
<PRE>
  39         |   %name UMINUS
  40               '-' $exp %prec NEG
  41                 { $lhs-&gt;{n} = -$exp-&gt;{n} }
</PRE>
¿Cual es la ambiguedad que surge con esta regla? 
Una de las ambiguedades de esta regla 
esta relacionada con el doble significado
del menos como operador unario y binario: hay frases
como <code>-e-e</code> que tiene dos posibles interpretaciones:
Podemos verla como <code>(-e)-e</code> o bien como <code>-(e-e)</code>.
Hay dos árboles posibles. El analizador, cuando este analizando
la entrada <code>-e-e</code> y vea el
segundo <code>-</code> deberá escoger uno de los dos árboles. 
¿Cuál?. 

<P>
El conflicto puede verse como una ``lucha'' entre
la regla <code>exp: '-' exp</code> la cual interpreta la frase como
<code>(-e)-e</code> y la segunda aparición del terminal <code>-</code> 
el cuál ``quiere entrar'' para que gane la regla <code>exp: exp '-' exp</code>
y dar lugar a la interpretación <code>-(e-e)</code>.

<P>
En este caso, si atendemos a la norma enunciada de que
la prioridad asociada con una regla de producción
es la del <U>último terminal</U> que aparece en dicha regla,
las dos reglas 
<!-- MATH
 $E \rightarrow - E$
 -->
<IMG
 WIDTH="73" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img371.png"
 ALT="$ E \rightarrow - E$">
 y <!-- MATH
 $E \rightarrow E - E$
 -->
<IMG
 WIDTH="95" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img372.png"
 ALT="$ E \rightarrow E - E$">
 tienen
la prioridad del terminal <code>-</code>.

<P>
Lo que hace la declaración <code>%prec NEG</code> de la línea
40 es modificar la prioridad de la regla <!-- MATH
 $E \rightarrow - E$
 -->
<IMG
 WIDTH="73" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img371.png"
 ALT="$ E \rightarrow - E$">

para que tenga la 
del terminal <code>NEG</code>. El terminal <code>NEG</code> lo declaramos
en la cabecera del programa, dándole la prioridad adecuada:
<PRE>
17  %right   '='
18  %left   '-' '+'
19  %left   '*' '/'
20  $right NEG
21  %%
</PRE>

<P>
<P>
<DIV><B>Ejercicio  9.2.1</B> &nbsp; 
<I>¿Cómo se hubiera interpretado la expresion <code>- e - e</code> si no
se hubiese introducido el terminal de desempate <code>NEG</code>?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  9.2.2</B> &nbsp; 
<I>¿Cómo se interpretará una expresion como <code>e = e - e</code>?</I></DIV><P></P>

<P>
</LI>
<LI>Tenga en cuenta que algunas funcionalidades proveídas por <code>Parse::Eyapp</code>
(por ejemplo las listas) suponen la inserción de reglas dentro de la gramática
de entrada y por tanto pueden dar lugar a ambiguedades.

<P>
</LI>
<LI>Una fuente de ambiguedad puede aparecer como consecuencia de la aparición de acciones
semánticas. Cuando se  inserta una acción <!-- MATH
 $\left \{ action_1\right \}$
 -->
<IMG
 WIDTH="78" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img453.png"
 ALT="$ \left \{ action_1\right \}$">

en medio de una regla <!-- MATH
 $A \rightarrow \alpha \beta$
 -->
<IMG
 WIDTH="67" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img114.png"
 ALT="$ A \rightarrow \alpha \beta $">
 :
<DIV ALIGN="CENTER">
<!-- MATH
 $A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$
 -->
<IMG
 WIDTH="222" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img454.png"
 ALT="$ A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$">

</DIV>
<code>eyapp</code> crea una variable sintáctica temporal <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img455.png"
 ALT="$ T$">
 e introduce una nueva regla:

<P>
<DIV ALIGN="CENTER">
</DIV>
<OL>
<LI><!-- MATH
 $A \rightarrow \alpha T \beta \left \{ action_2\right \}$
 -->
<IMG
 WIDTH="155" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img456.png"
 ALT="$ A \rightarrow \alpha T \beta \left \{ action_2\right \}$">
 
</LI>
<LI><!-- MATH
 $T \rightarrow \epsilon \left \{ action_1 \right \}$
 -->
<IMG
 WIDTH="127" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img457.png"
 ALT="$ T \rightarrow \epsilon \left \{ action_1 \right \}$">

</LI>
</OL>
<DIV ALIGN="CENTER">
</DIV>

<P>
esta modificación puede dar lugar a conflictos.

<P>
</LI>
</UL>

<P>

<H4><A NAME="SECTION0014200150000000000000">
La rutina de Tratamiento de Errores</A>
</H4>
  

<P>
Recuerde que la fase de análisis sintáctico y léxico de 
la entrada ocurre en Tree Construction Time.
En consecuencia el primer argumento que recibe el método <code>_Error</code> 
(líneas 53-59) cuando es llamado
por el analizador sintáctico es una referencia al objeto analizador 
sintáctico. Dicho objeto dispone de un conjunto de métodos, muchos de los cuales
ya existían en <code>Parse::Yapp</code>. Entre estos últimos se encuentra  el método
 YYCurval  que es llamado en la línea 55 y que devuelve
el terminal/token que estaba siendo analizado en el momento en el que 
se produjo el error. Si dicho token no está definido es que hemos alcanzado el
final del fichero (línea 56).

<P>
<PRE>
54  sub _Error {
55    my($token)=$_[0]-&gt;YYCurval;
56    my($what)= $token ? "input: '$token'" : "end of input";
57
58    die "Syntax error near $what.\n";
59  }
</PRE>

<P>
Otros métodos que pueden ser de ayuda en el diagnóstico de 
errores son  YYCurval  que devuelve el atributo del 
token actual y  YYExpect  que devuelve una lista
con los terminales esperados en el momento en el que se produjo
el error.

<P>

<H4><A NAME="SECTION0014200160000000000000">
El Analizador Léxico</A>
</H4>
  

<P>
El analizador léxico esta tomado de los ejemplos 
que acompañan a <code>Parse::Yapp</code>. Se supone que la entrada
se ha dejado dentro del objeto analizador en <code>$parser-&gt;YYData-&gt;{INPUT}</code>.
Recuerde que el análisis léxico de la entrada ocurre en Tree Construction Time.
En consecuencia el primer argumento que recibe <code>_Lexer</code> cuando es llamado
por el analizador sintáctico es la referencia al objeto analizador 
sintáctico. De ahí que lo primero que se hace, en la línea 59, sea 
crear en <code>$parser</code> una variable léxica que referencia dicho objeto.

<P>
<PRE>
58  sub _Lexer {
59      my($parser)=shift;
60
61          $parser-&gt;YYData-&gt;{INPUT}
62      or  return('',undef);
63
64      $parser-&gt;YYData-&gt;{INPUT}=~s/^\s*//;
65
66      for ($parser-&gt;YYData-&gt;{INPUT}) {
67          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
68          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
69          s/^(.)// and return($1,$1);
70          s/^\s*//;
71      }
72  }
</PRE>

<P>
<P>
<DIV><B>Ejercicio  9.2.3</B> &nbsp; 
<I>¿Cuantos elementos tiene la lista sobre la que se hace el bucle 
<code>for</code> de la línea 66?</I></DIV><P></P>

<P>
Obsérvese el <A NAME="21488"></A><B>falso bucle <TT>for</TT></B> en la línea 66. 
Es un truco que constituye una de esas frases hechas o <A NAME="21492"></A><B>idioms</B>
que aunque la primera vez resultan extrañas,
a fuerza de verlas repetidas se convierten en familiares.

<P>
El bucle de hecho se ejecutará una sóla vez en cada llamada 
a <code>_Lexer</code>. El objetivo es evitar las costosas indirecciones
a las que obliga almacenar la entrada en <code>$parser-&gt;YYData-&gt;{INPUT}</code>.
Para ello se aprovecha la capacidad del bucle <code>for</code> sin índice
<B>de crear en</B> <code>$_</code> <B>un alias del elemento visitado en la iteración</B>.

<P>
<P>
<DIV><B>Ejercicio  9.2.4</B> &nbsp; 
<OL>
<LI>¿Puedo cambiar el binding de la línea 64 por uno sobre
<code>$_</code> dentro del falso <code>for</code>? ¿Ganamos algo con ello?

<P>
</LI>
<LI>¿Puedo cambiar la comprobación en las líneas 61-62
por una primera línea dentro del falso <code>for</code> que diga
<code>$_ or return('',undef);</code>?

<P>
</LI>
<LI>¿Cuántas veces se ejecuta el falso bucle si <code>$parser-&gt;YYData-&gt;{INPUT}</code>
contiene la cadena vacía?

<P>
</LI>
<LI>¿Que ocurrirá en las líneas 61-62 
si <code>$parser-&gt;YYData-&gt;{INPUT}</code> contiene sólamente la cadena '0'?
</LI>
</OL>
<P></DIV><P></P>

<P>

<H4><A NAME="SECTION0014200170000000000000">
Acciones por Defecto</A>
</H4>
  

<P>
En el ejemplo anterior la acción es asociada con los nodos
<code>PLUS</code>, <code>MINUS</code>, <code>TIMES</code> y <code>DIV</code> es similar.
<code>Parse::Eyapp</code> proporciona una directiva <code>%</code> defaultaction 
la cual permite especificar la acción por defecto. Esta acción es asociada
con las reglas que no tienen una acción asociada explícita. El siguiente
ejemplo muestra su uso:

<P>
<PRE>
nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; cat -n trans_scheme_default_action.pl
 1  #!/usr/bin/perl
 2  use strict;
 3  use warnings;
 4  use Data::Dumper;
 5  use Parse::Eyapp;
 6  use IO::Interactive qw(interactive);
 7
 8  my $translationscheme = q{
 9    %{
10    # head code is available at tree construction time
11    use Data::Dumper;
12
13    our %sym; # symbol table
14    %}
15
16    %defaultaction { $lhs-&gt;{n} = eval " $left-&gt;{n} $_[2]-&gt;{attr} $right-&gt;{n} " }
17
18    %metatree
19
20    %right   '='
21    %left   '-' '+'
22    %left   '*' '/'
23
24    %%
25    line:       %name EXP
26                  exp &lt;+ ';'&gt; /* Expressions separated by semicolons */
27                    { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
28    ;
29
30    exp:
31                %name PLUS
32                  exp.left '+' exp.right
33            |   %name MINUS
34                  exp.left '-' exp.right
35            |   %name TIMES
36                  exp.left '*' exp.right
37            |   %name DIV
38                  exp.left '/' exp.right
39            |   %name NUM   $NUM
40                    { $lhs-&gt;{n} = $NUM-&gt;{attr} }
41            |   '(' $exp ')'  %begin { $exp }
42            |   %name VAR
43                  $VAR
44                    { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} }
45            |   %name ASSIGN
46                  $VAR '=' $exp
47                    { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
48
49    ;
50
51    %%
52    sub Error {
53      die "Syntax error near ".($_[0]-&gt;YYCurval?$_[0]-&gt;YYCurval:"end of file")."\n";
54    }
55
56    sub Lexer {
57      my($parser)=shift;
58
59      for ($parser-&gt;YYData-&gt;{INPUT}) {
60        s/^\s*//;
61        $_ eq '' and  return('',undef);
62        s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
63        s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
64        s/^(.)// and return($1,$1);
65      }
66    }
67  }; # end translation scheme
68
69  $Data::Dumper::Indent = 1;
70  $Data::Dumper::Terse = 1;
71  $Data::Dumper::Deepcopy  = 1;
72  my $warnings = Parse::Eyapp-&gt;new_grammar(
73    input=&gt;$translationscheme,
74    classname=&gt;'Calc',
75    firstline =&gt; 6,
76    outputfile =&gt; 'Calc.pm');
77  die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;
78  my $parser = Calc-&gt;new();
79  print {interactive} "Write a sequence of arithmetic expressions: ";
80  $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
81  my $t = $parser-&gt;YYParse( yylex =&gt; \&amp;Calc::Lexer, yyerror =&gt; \&amp;Calc::Error );
82  $t-&gt;translation_scheme;
83  my $treestring = Dumper($t);
84  my $symboltable;
85  {
86    no warnings;
87    $symboltable = Dumper(\%Calc::sym);
88  }
89  print &lt;&lt;"EOR";
90  ***********Tree*************
91  $treestring
92  ******Symbol table**********
93  $symboltable
94  ************Result**********
95  $t-&gt;{n}
96
97  EOR
</PRE>

<P>
El método  Last_child  usado en la línea 27 devuelve una referencia al
último hijo no código del nodo.
Al ser <code>$_[1]</code> un nodo de tipo  '_PLUS_LIST'  queda garantizado que
el último hijo no es una referencia a una subrutina asi que podría haberse 
usado el método  last_child  el cual devuelve el último hijo 
del nodo, sea este código o no.

<P>
La línea 86 tiene por efecto desactivar los avisos. De otra manera se produciría 
un  warning  con respecto al uso único de la variable <code>%Calc::sym</code>:
<PRE>
nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; echo "a=2*3; b=a+1" | trans_scheme_default_action.pl
Name "Calc::sym" used only once: possible typo at trans_scheme_default_action.pl line 85.
***********Tree*************
bless( {
  'n' =&gt; 7,
  'children' =&gt; [
    ............
  ]
}, 'EXP' )

******Symbol table**********
{
  'a' =&gt; { 'n' =&gt; 6 },
  'b' =&gt; { 'n' =&gt; 7 }
}

************Result**********
7
</PRE>

<P>

<H4><A NAME="SECTION0014200180000000000000">
Un Esquema  de Traducción para las Declaraciones de Variables</A>
</H4>
  

<P>
En el siguiente ejemplo se muestra la implementación en <code>eyapp</code> del ejemplo
<A HREF="node139.html#example:typesandts">4.7.1</A>. El código es similar salvo por la presencia 
de flechas de referenciado:

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n trans_scheme_simple_decls2.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Data::Dumper;
 4  use Parse::Eyapp;
 5  our %s; # symbol table
 6
 7  my $ts = q{
 8    %token FLOAT INTEGER NAME
 9
10    %{
11    our %s;
12    %}
13
14    %metatree
15
16    %%
17    Dl:  D &lt;* ';'&gt;
18    ;
19
20    D : $T { $L-&gt;{t} = $T-&gt;{t} } $L
21    ;
22
23    T : FLOAT    { $lhs-&gt;{t} = "FLOAT" }
24      | INTEGER  { $lhs-&gt;{t} = "INTEGER" }
25    ;
26
27    L : $NAME
28          { $NAME-&gt;{t} = $lhs-&gt;{t}; $s{$NAME-&gt;{attr}} = $NAME }
29      | $NAME { $NAME-&gt;{t} = $lhs-&gt;{t}; $L-&gt;{t} = $lhs-&gt;{t} } ',' $L
30          { $s{$NAME-&gt;{attr}} = $NAME }
31    ;
32    %%
33  };
34
35  sub Error { die "Error sintáctico\n"; }
36
37  { # Closure of $input, %reserved_words and $validchars
38    my $input = "";
39    my %reserved_words = ();
40    my $validchars = "";
41
42    sub parametrize__scanner {
43      $input = shift;
44      %reserved_words = %{shift()};
45      $validchars = shift;
46    }
47
48    sub scanner {
49      $input =~ m{\G\s+}gc;                     # skip whites
50      if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {
51        my $w = uc($1);                 # upper case the word
52        return ($w, $w) if exists $reserved_words{$w};
53        return ('NAME', $1);            # not a reserved word
54      }
55      return ($1, $1) if ($input =~ m/\G([$validchars])/gc);
56      die "Caracter invalido: $1\n" if ($input =~ m/\G(\S)/gc);
57      return ('', undef); # end of file
58    }
59  } # end closure
60
61  Parse::Eyapp-&gt;new_grammar(input=&gt;$ts, classname=&gt;'main', outputfile=&gt;'Types.pm');
62  my $parser = main-&gt;new(yylex =&gt; \&amp;scanner, yyerror =&gt; \&amp;Error); # Create the parser
63
64  parametrize__scanner(
65    "float x,y;\ninteger a,b\n",
66    { INTEGER =&gt; 'INTEGER', FLOAT =&gt; 'FLOAT'},
67    ",;"
68  );
69
70  my $t = $parser-&gt;YYParse() or die "Syntax Error analyzing input";
71
72  $t-&gt;translation_scheme;
73
74  $Data::Dumper::Indent = 1;
75  $Data::Dumper::Terse = 1;
76  $Data::Dumper::Deepcopy  = 1;
77  $Data::Dumper::Deparse = 1;
78  print Dumper($t);
79  print Dumper(\%s);
</PRE>
Al ejecutarlo con la entrada <code>"float x,y;\ninteger a,b\n"</code>
los contenidos finales del arbol son:
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; trans_scheme_simple_decls2.pl
bless({'children'=&gt;[
   bless({'children'=&gt;[
   |   bless({'children'=&gt;[
   |   |   bless({'children'=&gt;[
   |   |   |   bless({'children'=&gt;[],'attr'=&gt;'FLOAT','token'=&gt;'FLOAT'},'TERMINAL'),
   |   |   |   sub {use strict 'refs'; my $lhs=$_[0]; $$lhs{'t'}='FLOAT'; }
   |   |   | ],
   |   |   | 't'=&gt;'FLOAT'
   |   |   },'T_8'),       # T -&gt; FLOAT
   |   |   sub { ... },
   |   |   bless({'children'=&gt;[
   |   |   |   bless({'children'=&gt;[],'attr'=&gt;'x','token'=&gt;'NAME','t'=&gt;'FLOAT'},'TERMINAL'),
   |   |   |   sub{ ... },
   |   |   |   bless({'children'=&gt;[],'attr'=&gt;',','token'=&gt;','},'TERMINAL'),
   |   |   |   bless({'children'=&gt;[
   |   |   |   |   bless({'children'=&gt;[],'attr'=&gt;'y','token'=&gt;'NAME','t'=&gt;'FLOAT'},
   |   |   |   |         'TERMINAL'),
   |   |   |   |   sub{ ... }
   |   |   |   | ],
   |   |   |   | 't'=&gt;'FLOAT'
   |   |   |   },'L_10'), # L -&gt; NAME
   |   |   |   sub{ ... }
   |   |   | ],
   |   |   | 't'=&gt;'FLOAT'
   |   |   },'L_11'),     # L -&gt; NAME ',' L 
   |   |   undef
   |   | ]
   |   },'D_6'),          # D -&gt; T L
   |   bless({ 
   |    ... # tree for integer a, b
   |   },'D_6')           # D -&gt; T L
   | ]
   },'_STAR_LIST_1'),
 ]
},'Dl_5')   # Dl : D &lt;* ';'&gt; equivale a: Dl : /* empty */ | S_2; S_2: S_1; S_1: S_1 ';' D | D
</PRE>
Los contenidos de la tabla de símbolos <code>%s</code> quedan como sigue:
<PRE>
{
 'y'=&gt;bless({'children'=&gt;[],'attr'=&gt;'y','token'=&gt;'NAME','t'=&gt;'FLOAT'},'TERMINAL'),
 'a'=&gt;bless({'children'=&gt;[],'attr'=&gt;'a','token'=&gt;'NAME','t'=&gt;'INTEGER'},'TERMINAL'),
 'b'=&gt;bless({'children'=&gt;[],'attr'=&gt;'b','token'=&gt;'NAME','t'=&gt;'INTEGER'},'TERMINAL'),
 'x'=&gt;bless({'children'=&gt;[],'attr'=&gt;'x','token'=&gt;'NAME','t'=&gt;'FLOAT'},'TERMINAL')
}
</PRE>

<P>

<H4><A NAME="SECTION0014200190000000000000">
Prefijos</A>
</H4>
  

<P>
<A NAME="paragraph:eyappprefix"></A>Como se ha mencionado, durante la fase <B>Tree Construction</B>
los nodos son bendecidos en el nombre de la regla
de producción. <A NAME="21506"></A><B>El nombre de una regla de producción</B> es, por defecto,
la concatenación de la variable en el lado izquierdo
(<A NAME="21508"></A><B>LHS</B>) con el número de orden de la regla. 
Es  posible modificar el nombre por defecto usando
la directiva  %name . 

<P>
<I>Si se desean evitar posibles colisiones con clases existentes
es posible prefijar todos los nombres de las clases
con un prefijo dado usando el parámetro  yyprefix  en la llamada
al constructor del analizador</I>:

<P>
<PRE>
my $warnings = Parse::Eyapp-&gt;new_grammar(
  input=&gt;$translationscheme,
  classname=&gt;'main',
  firstline =&gt; 6,
  outputfile =&gt; 'main.pm');
die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;

# Prefix all the classes with 'Calc::'
my $parser = main-&gt;new(yyprefix =&gt; 'Calc::');
</PRE>
El resultado de esta llamada a <code>new</code> es que las clases de los nodos 
quedan prefijadas con <code>Calc::</code>. Por ejemplo el árbol creado
para la frase <code>a=1</code> será:
<PRE>
bless( { 'children' =&gt; [
    bless( { 'children' =&gt; [
        bless( { 'children' =&gt; [
            bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'Calc::TERMINAL' ),
            bless( { 'children' =&gt; [], 'attr' =&gt; '=', 'token' =&gt; '=' }, 'Calc::TERMINAL' ),
            bless( { 'children' =&gt; [
                bless( { 'children' =&gt; [], 'attr' =&gt; '1', 'token' =&gt; 'NUM' }, 'Calc::TERMINAL' ),
              ]
            }, 'Calc::NUM' ),
          ]
        }, 'Calc::ASSIGN' )
      ]
    }, 'Calc::_PLUS_LIST' ),
  ]
}, 'Calc::EXP' )
</PRE>

<P>

<H4><A NAME="SECTION0014200200000000000000">
Modo Standalone</A>
</H4>
  

<P>
Es mas eficiente aislar el código del esquema de traducción en un fichero 
(se asume por defecto el tipo <code>.eyp</code>) y generar el módulo que contiene
el código del analizador usando el guión  eyapp .

<P>
El siguiente ejemplo muestra un ejemplo de compilación separada.
El esquema de traducción convierte expresiones
en infijo a postfijo. De un lado tenemos el fichero <code>TSPostfix2.eyp</code>
conteniendo el esquema:

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n TSPostfix2.eyp
 1  # File TSPostfix2.eyp
 2  %right  '='
 3  %left   '-' '+'
 4  %left   '*' '/'
 5  %left   NEG
 6
 7  %{
 8    use Data::Dumper;
 9    $Data::Dumper::Indent = 1;
10    $Data::Dumper::Deepcopy = 1;
11    #$Data::Dumper::Deparse = 1;
12    use IO::Interactive qw(interactive);
13  %}
14
15  %metatree
16
17  %defaultaction {
18    if (@_==4) { # binary operations: 4 = lhs, left, operand, right
19      $lhs-&gt;{t} = "$_[1]-&gt;{t} $_[3]-&gt;{t} $_[2]-&gt;{attr}";
20      return
21    }
22    die "Fatal Error. Unexpected input\n".Dumper(@_);
23  }
24
25  %%
26  line: %name PROG
27         exp &lt;%name EXP + ';'&gt;
28           { @{$lhs-&gt;{t}} = map { $_-&gt;{t}} ($lhs-&gt;child(0)-&gt;Children()); }
29
30  ;
31
32  exp:        NUM         { $lhs-&gt;{t} = $_[1]-&gt;{attr}; }
33          |   VAR         { $lhs-&gt;{t} = $_[1]-&gt;{attr}; }
34          |   VAR '=' exp { $lhs-&gt;{t} = "$_[1]-&gt;{attr} $_[3]-&gt;{t} =" }
35          |   exp '+' exp
36          |   exp '-' exp
37          |   exp '*' exp
38          |   exp '/' exp
39          |   '-' exp %prec NEG { $_[0]-&gt;{t} = "$_[2]-&gt;{t} NEG" }
40          |   '(' exp ')' %begin { $_[2] }
41  ;
42
43  %%
44
45  sub _Error {
46      my($token)=$_[0]-&gt;YYCurval;
47
48      my($what)= $token ? "input: '$token'" : "end of input";
49      die "Syntax error near $what.\n";
50  }
51
52  my $x; # Used for input
53
54  sub _Lexer {
55      my($parser)=shift;
56
57      $x =~ s/^\s+//;
58      return('',undef) if $x eq '';
59
60
61      $x =~ s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
62      $x =~ s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
63      $x =~ s/^(.)//s                    and return($1,$1);
64  }
65
66  sub Run {
67      my($self)=shift;
68      $x = &lt;&gt;;
69      my $tree = $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
70        #yydebug =&gt; 0xFF
71      );
72
73      print Dumper($tree);
74      $tree-&gt;translation_scheme();
75      print Dumper($tree);
76      {
77        local $" = ";";
78        print "Translation:\n@{$tree-&gt;{t}}\n";
79      }
80  }
</PRE>
Observe el uso del método  Children  - con <TT>C</TT> mayúscula -
en la línea 28: 
<B>devuelve los hijos del nodo no incluyendo las referencias
a subrutinas</B>.
A diferencia de su homólogo con <TT>c</TT>  minúscula   children  
el cual devuelve todos los hijos del nodo, 
incluyendo las referencias al código empotrado.

<P>
Compilamos con <code>eyapp</code>:
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; eyapp TSPostfix2
nereida:~/src/perl/YappWithDefaultAction/examples&gt; ls -ltr | tail -2
-rw-r-----  1 pl users   1781 2006-10-30 13:08 TSPostfix2.eyp
-rw-r--r--  1 pl users   7611 2006-10-30 13:12 TSPostfix2.pm
</PRE>

<P>
De otro lado tenemos el programa cliente 
el cual  se limita a cargar el módulo y llamar
al método <code>Run</code>:

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n usetspostfix2.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use TSPostfix2;
     4
     5  my $parser = new TSPostfix2();
     6  $parser-&gt;Run;
</PRE>
Al ejecutar el programa se produce una salida similar a esta
(la salida ha sido editada para darle mayor claridad):

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; usetspostfix2.pl
 1  a=2
 2  ...
 3  $VAR1 = bless( { 'children' =&gt; [
 4      bless( { 'children' =&gt; [
 5      |   bless( { 'children' =&gt; [
 6      |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
 7      |   |   bless( { 'children' =&gt; [], 'attr' =&gt; '=', 'token' =&gt; '=' }, 'TERMINAL' ),
 8      |   |   bless( { 'children' =&gt; [
 9      |   |       bless( { 'children' =&gt; [], 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'TERMINAL' ),
10      |   |       sub { "DUMMY" }
11      |   |     ],
12      |   |     't' =&gt; '2'
13      |   |   }, 'exp_4' ),
14      |   |   sub { "DUMMY" }
15      |   | ],
16      |   | 't' =&gt; 'a 2 ='
17      |   }, 'exp_6' )
18      | ]
19      }, 'EXP' ),
20      sub { "DUMMY" }
21    ],
22    't' =&gt; [ 'a 2 =' ]
23  }, 'PROG' );
24  Translation:
25  a 2 =
</PRE>

<P>
Como puede verse en la salida, cuando no se especifica el nombre del nodo asociado
con la regla de producción se genera un <A NAME="21514"></A><B>nombre por defecto</B> que consiste en la concatenación
del nombre de la variable sintáctica en el lado izquierdo y el número de orden 
de la regla de producción. Así el nodo descrito en las líneas 5-17 tiene por nombre 
<code>exp_6</code> indicando que corresponde a la sexta regla de producción de <code>exp</code>.

<P>
El nodo en las líneas 4-19 tiene por nombre <code>EXP</code>. Su nombre
le fué dado mediante la directiva <code>%name</code> en la línea
<PRE>
27         exp &lt;%name EXP + ';'&gt;
</PRE>
Es posible insertar una directiva  %name en una lista  usando esta
sintáxis.

<P>
Nótese también que si hubieramos usado la opción  Data::Dumper::Deparse  (línea 11) podríamos
hacer que <code>Data::Dumper</code> nos informe no sólo de la presencia de código
sino que nos muestre el código fuente que ocupa esa posición.

<P>
<BR> <HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL>
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html5394"
  HREF="node263.html#SECTION001420010000000000000">Partes de un programa <TT>eyapp</TT></A>
<LI><A NAME="tex2html5395"
  HREF="node263.html#SECTION001420020000000000000">Esquemas de Traducción con <TT>%metatree</TT></A>
<LI><A NAME="tex2html5396"
  HREF="node263.html#SECTION001420030000000000000">Las reglas</A>
<LI><A NAME="tex2html5397"
  HREF="node263.html#SECTION001420040000000000000">Nombres de los atributos</A>
<LI><A NAME="tex2html5398"
  HREF="node263.html#SECTION001420050000000000000">Nombres de atributos de expresiones complejas Eyapp</A>
<LI><A NAME="tex2html5399"
  HREF="node263.html#SECTION001420060000000000000">Fases de un Esquema de Traducción</A>
<LI><A NAME="tex2html5400"
  HREF="node263.html#SECTION001420070000000000000">Class Construction Time</A>
<LI><A NAME="tex2html5401"
  HREF="node263.html#SECTION001420080000000000000">Tree Construction Time</A>
<LI><A NAME="tex2html5402"
  HREF="node263.html#SECTION001420090000000000000">La directiva <TT>%name class</TT></A>
<LI><A NAME="tex2html5403"
  HREF="node263.html#SECTION0014200100000000000000">La directiva <TT>%begin</TT></A>
<LI><A NAME="tex2html5404"
  HREF="node263.html#SECTION0014200110000000000000">Execution Time</A>
<LI><A NAME="tex2html5405"
  HREF="node263.html#SECTION0014200120000000000000">Los Terminales</A>
<LI><A NAME="tex2html5406"
  HREF="node263.html#SECTION0014200130000000000000">Listas y Opcionales</A>
<LI><A NAME="tex2html5407"
  HREF="node263.html#SECTION0014200140000000000000">Ambiguedades</A>
<LI><A NAME="tex2html5408"
  HREF="node263.html#SECTION0014200150000000000000">La rutina de Tratamiento de Errores</A>
<LI><A NAME="tex2html5409"
  HREF="node263.html#SECTION0014200160000000000000">El Analizador Léxico</A>
<LI><A NAME="tex2html5410"
  HREF="node263.html#SECTION0014200170000000000000">Acciones por Defecto</A>
<LI><A NAME="tex2html5411"
  HREF="node263.html#SECTION0014200180000000000000">Un Esquema  de Traducción para las Declaraciones de Variables</A>
<LI><A NAME="tex2html5412"
  HREF="node263.html#SECTION0014200190000000000000">Prefijos</A>
<LI><A NAME="tex2html5413"
  HREF="node263.html#SECTION0014200200000000000000">Modo Standalone</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>
<A NAME="tex2html5392"
  HREF="node264.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html5386"
  HREF="node261.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html5380"
  HREF="node262.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html5388"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html5390"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html5393"
  HREF="node264.html">Definición Dirigida por la</A>
<B>Sup:</B> <A NAME="tex2html5387"
  HREF="node261.html">Análisis Semántico con Parse::Eyapp</A>
<B> Ant:</B> <A NAME="tex2html5381"
  HREF="node262.html">Esquemas de Traducción: Conceptos</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
