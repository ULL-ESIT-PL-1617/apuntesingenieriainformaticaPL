<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Introducción</TITLE>
<META NAME="description" CONTENT="Introducción">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node87.html">
<LINK REL="previous" HREF="node85.html">
<LINK REL="up" HREF="node85.html">
<LINK REL="next" HREF="node87.html">
</HEAD>

<BODY >

<A NAME="tex2html2562"
  HREF="node87.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2556"
  HREF="node85.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2550"
  HREF="node85.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2558"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2560"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2563"
  HREF="node87.html">Objetos</A>
<B>Sup:</B> <A NAME="tex2html2557"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
<B> Ant:</B> <A NAME="tex2html2551"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html2564"
  HREF="node86.html#SECTION008111010000000000000">El Problema</A>
<LI><A NAME="tex2html2565"
  HREF="node86.html#SECTION008111020000000000000">Una solución: <TT>Regexp::Grammars</TT></A>
<LI><A NAME="tex2html2566"
  HREF="node86.html#SECTION008111030000000000000">La sintaxis de una expresión regular <TT>Regexp::Grammars</TT></A>
<LI><A NAME="tex2html2567"
  HREF="node86.html#SECTION008111040000000000000">El hash <TT>%/</TT>: Una representación del AST</A>
<LI><A NAME="tex2html2568"
  HREF="node86.html#SECTION008111050000000000000">Diferencias entre <TT>token</TT> y <TT>rule</TT></A>
<LI><A NAME="tex2html2569"
  HREF="node86.html#SECTION008111060000000000000">Redefinición de los espacios en blanco</A>
<LI><A NAME="tex2html2570"
  HREF="node86.html#SECTION008111070000000000000">Llamando a las subreglas</A>
<LI><A NAME="tex2html2571"
  HREF="node86.html#SECTION008111080000000000000">Eliminación del anidamiento de ramas unarias en <TT>%/</TT></A>
<LI><A NAME="tex2html2572"
  HREF="node86.html#SECTION008111090000000000000">Ámbito de uso de <TT>Regexp::Grammars</TT></A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION008111000000000000000">
Introducción</A>
</H2>

<P>

<H4><A NAME="SECTION008111010000000000000">
El Problema</A>
</H4>
  

<P>
La documentación de <A NAME="tex2html180"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A> establece cual es el problema que aborda 
el módulo:
<BLOCKQUOTE><I>...Perl5.10 makes possible to use regexes to recognize complex,
hierarchical-and even recursive-textual structures. The problem is that
Perl 5.10 doesn’t provide any support for extracting that
hierarchical data into nested data structures. In other words,
using Perl 5.10 you can match complex data, but not parse it into an internally useful form.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>An additional problem when using Perl 5.10 regexes to match
complex data formats is that you have to make sure you remember
to insert whitespace- matching constructs (such as <code>\s*</code>) at every
possible position where the data might contain ignorable whitespace. This
reduces the readability of such patterns, and increases the chance of
errors (typically caused by overlooking a location where whitespace
might appear).
</I></BLOCKQUOTE>
<P>
<H4><A NAME="SECTION008111020000000000000">
Una solución: <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
The <A NAME="tex2html181"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A> module solves both those problems.

<P>
If you import the module into a particular lexical scope, it preprocesses
any regex in that scope, so as to implement a number of extensions to the
standard Perl 5.10 regex syntax. These extensions simplify the task of
defining and calling subrules within a grammar, and allow those subrule
calls to capture and retain the components of they match in a proper
hierarchical manner.

<P>

<P>

<H4><A NAME="SECTION008111030000000000000">
La sintaxis de una expresión regular <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
Las expresiones regulares <A NAME="tex2html184"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A> aumentan las regexp Perl 5.10. La sintáxis
se expande y se modifica:

<P>
<BLOCKQUOTE><I>A <A NAME="tex2html182"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A> specification consists of a pattern (which may include both standard Perl 5.10 regex syntax, as well as special
<A NAME="tex2html183"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
directives), followed by one or more rule or token definitions.
</I></BLOCKQUOTE>

<P>
Sigue un ejemplo:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (&lt;pp&gt;)
    10
    11        &lt;rule: pp&gt;   \( (?: [^()]*+ | &lt;escape&gt; | &lt;pp&gt; )* \)
    12
    13        &lt;token: escape&gt; \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = &lt;&gt;) {
    19      while ($input =~ m{$rbb}g) {
    20          say("matches: &lt;$&amp;&gt;");
    21          say Dumper \%/;
    22      }
    23  }
</PRE>

<P>
<BLOCKQUOTE><I>Note that there is no need to explicitly place <code>\s*</code> 
subpatterns throughout the rules; that is taken care of automatically.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The initial pattern (<code>(&lt;pp&gt;)</code>) acts like the <B>top</B> rule of the grammar, and must
be matched completely for the grammar to match.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The rules and tokens are declarations only and they are not directly
matched.  Instead, they act like subroutines, and are invoked by name
from the initial pattern (or from within a rule or token).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Each rule or token extends from the directive that introduces it up to
either the next rule or token directive, or (in the case of the final
rule or token) to the end of the grammar.  
</I></BLOCKQUOTE>
<P>

<P>

<H4><A NAME="SECTION008111040000000000000">
El hash <TT>%/</TT>: Una representación del AST</A>
</H4>
  

Al ejecutar el programa anterior con entrada <code>(2*(3+5))*4+(2-3)</code> produce:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: &lt;(2*(3+5))&gt;
$VAR1 = {
          '' =&gt; '(2*(3+5))',
          'pp' =&gt; {
                    '' =&gt; '(2*(3+5))',
                    'pp' =&gt; '(3+5)'
                  }
        };

matches: &lt;(2-3)&gt;
$VAR1 = {
          '' =&gt; '(2-3)',
          'pp' =&gt; '(2-3)'
        };
</PRE>

<P>
<BLOCKQUOTE><I>Each rule calls the
subrules specified within it, and then return a hash containing whatever
result each of those subrules returned, with each result indexed by the
subrule’s name.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In this way, each level of the hierarchical regex can generate hashes
recording everything its own subrules matched, so when the entire pattern
matches, it produces a tree of nested hashes that represent the structured
data the pattern matched.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In addition each result-hash has one extra key: the empty string. The
value for this key is whatever string the entire subrule call matched.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION008111050000000000000">
Diferencias entre <TT>token</TT> y <TT>rule</TT></A>
</H4>
  

<P>
<BLOCKQUOTE><I>The difference between a token and a rule is that a token treats any
whitespace within it exactly as a normal Perl regular expression would.
That is, a sequence of whitespace in a token is ignored if the <code>/x</code>
modifier is in effect, or else matches the same literal sequence of
whitespace characters (if <code>/x</code> is not in effect).
</I></BLOCKQUOTE>
<P>

<P>
En el ejemplo anterior el comportamiento es el mismo si se reescribe la regla 
para el token <code>escape</code> como:
<PRE>
    13        &lt;rule: escape&gt; \\.
</PRE>
En este otro ejemplo mostramos que la diferencia entre token y rule
es significativa:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        &lt;s&gt;
    10
    11        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
    12
    13        &lt;rule: c&gt;  c d
    14
    15        &lt;token: a&gt;  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = &lt;&gt;) {
    21      if ($input =~ m{$rbb}) {
    22          say("matches: &lt;$&amp;&gt;");
    23          say Dumper \%/;
    24      }
    25      else {
    26          say "Does not match";
    27      }
    28  }
</PRE>

<P>
Al ejecutar este programa vemos la diferencia en la interpretación de los blancos:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: &lt;ab c d&gt;
$VAR1 = {
          '' =&gt; 'ab c d',
          's' =&gt; {
                   '' =&gt; 'ab c d',
                   'c' =&gt; 'c d',
                   'a' =&gt; 'ab'
                 }
        };

a b c d
Does not match
ab cd
matches: &lt;ab cd&gt;
$VAR1 = {
          '' =&gt; 'ab cd',
          's' =&gt; {
                   '' =&gt; 'ab cd',
                   'c' =&gt; 'cd',
                   'a' =&gt; 'ab'
                 }
        };
</PRE>
Obsérvese como la entrada <code>a b c d</code> es rechazada mientras
que la entrada <code>ab c d</code> es aceptada.

<P>

<H4><A NAME="SECTION008111060000000000000">
Redefinición de los espacios en blanco</A>
</H4>
  

<P>
<BLOCKQUOTE><I>In a rule, any sequence of whitespace (except those at the very start
and the very end of the rule) is treated as matching the implicit subrule
<code>&lt;.ws&gt;</code>, which is automatically predefined to match optional whitespace 
(i.e. <code>\s*</code>).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>You can explicitly define a <code>&lt;ws&gt;</code> token to change that default
behaviour. For example, you could alter the definition of whitespace
to include Perlish comments, by adding an explicit <code>&lt;token: ws&gt;</code>:
</I></BLOCKQUOTE>
<P><PRE>
                      &lt;token: ws&gt;
                         (?: \s+ | #[^\n]* )*
</PRE>
<P>
<BLOCKQUOTE><I>But be careful not to define <code>&lt;ws&gt;</code> as a rule, as this will lead
to all kinds of infinitely recursive unpleasantness.
</I></BLOCKQUOTE>
El siguiente ejemplo ilustra como redefinir <code>&lt;ws&gt;</code>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings 'uninitialized';
 9      qr{
10        &lt;s&gt;
11
12        &lt;token: ws&gt; (?: \s+ | /\* .*? \*/)*+
13
14        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
15
16        &lt;rule: c&gt;  c d
17
18        &lt;token: a&gt;  a b
19
20      }xs;
21  };
22
23  while (my $input = &lt;&gt;) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say "Does not match";
29      }
30  }
</PRE>
Ahora podemos introducir comentarios en la entrada:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          '' =&gt; 'ab /* 1 */ c d',
          's' =&gt; {
                   '' =&gt; 'ab /* 1 */ c d',
                   'c' =&gt; 'c d',
                   'a' =&gt; 'ab'
                 }
        };
</PRE>

<P>

<H4><A NAME="SECTION008111070000000000000">
Llamando a las subreglas</A>
</H4>
  

<P>
<BLOCKQUOTE><I>To invoke a rule to match at any point, just enclose the rule’s name
in angle brackets (like in <A NAME="tex2html185"
  HREF="http://en.wikipedia.org/wiki/Perl_6">Perl 6</A>). There must be no space between the
opening bracket and the rulename. For example:
</I></BLOCKQUOTE>
<P><PRE>
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               &lt;name&gt;            # Call &lt;rule: name&gt;
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it's okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;
</PRE>
<P>
<BLOCKQUOTE><I>If you need to match a literal pattern that would otherwise look like a subrule call, just backslash-escape the leading angle:
</I></BLOCKQUOTE>
<P><PRE>
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               \&lt;name&gt;           # Match literal sequence '&lt;' 'n' 'a' 'm' 'e' '&gt;'
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it's okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;
</PRE>

<P>
El siguiente programa ilustra algunos puntos discutidos en la cita anterior:
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (&lt;pp&gt;)
10
11        &lt;rule: pp&gt;   \( (?: &lt;b  &gt; | \&lt; | &lt; escape&gt; | &lt;pp&gt; )* \)
12
13        &lt;token: b  &gt; b
14
15        &lt;token: escape&gt; \\.
16
17      }xs;
18  };
19
20  while (my $input = &lt;&gt;) {
21      while ($input =~ m{$rbb}g) {
22          say("matches: &lt;$&amp;&gt;");
23          say Dumper \%/;
24      }
25  }
</PRE>

<P>
Obsérvense los blancos en <code>&lt; escape&gt;</code> y en <code>&lt;token: b  &gt; b</code>.
Pese a ello el programa funciona:

<P>
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: &lt;(\(\))&gt;
$VAR1 = {
          '' =&gt; '(\\(\\))',
          'pp' =&gt; {
                    '' =&gt; '(\\(\\))',
                    'escape' =&gt; '\\)'
                  }
        };

(b)
matches: &lt;(b)&gt;
$VAR1 = {
          '' =&gt; '(b)',
          'pp' =&gt; {
                    '' =&gt; '(b)',
                    'b' =&gt; 'b'
                  }
        };

(&lt;)
matches: &lt;(&lt;)&gt;
$VAR1 = {
          '' =&gt; '(&lt;)',
          'pp' =&gt; '(&lt;)'
        };

(c)

casiano@millo:
</PRE>

<P>

<H4><A NAME="SECTION008111080000000000000">
Eliminación del anidamiento de ramas unarias en <TT>%/</TT></A>
</H4>
  

<P>
<BLOCKQUOTE><I>...Note, however, that if the result-hash at any level contains only the
empty-string key (i.e. the subrule did not call any sub-subrules or
save any of their nested result-hashes), then the hash is <I>unpacked</I>
and just the matched substring itself if returned.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example, if <code>&lt;rule: sentence&gt;</code> had been defined:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sentence&gt;
        I see dead people
</PRE>
<P>
<BLOCKQUOTE><I>then a successful call to the rule would only add:
</I></BLOCKQUOTE>
<P><PRE>
    sentence =&gt; 'I see dead people'
</PRE>
<P>
<BLOCKQUOTE><I>to the current result-hash.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This is a useful feature because it prevents a series of nested subrule
calls from producing very unwieldy data structures. For example, without
this automatic unpacking, even the simple earlier example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sentence&gt;
        &lt;noun&gt; &lt;verb&gt; &lt;object&gt;
</PRE>
<P>
<BLOCKQUOTE><I>would produce something needlessly complex, such as:
</I></BLOCKQUOTE>
<P><PRE>
    sentence =&gt; {
        ""     =&gt; 'I saw a dog',
        noun   =&gt; {
            "" =&gt; 'I',
        },
        verb   =&gt; {
            "" =&gt; 'saw',
        },
        object =&gt; {
            ""      =&gt; 'a dog',
            article =&gt; {
                "" =&gt; 'a',
            },
            noun    =&gt; {
                "" =&gt; 'dog',
            },
        },
    }
</PRE>

<P>
El siguiente ejemplo ilustra este punto:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        &lt;s&gt;
10
11        &lt;rule: s&gt; &lt;noun&gt; &lt;verb&gt; &lt;object&gt;
12
13        &lt;token: noun&gt; he | she | Peter | Jane
14
15        &lt;token: verb&gt; saw | sees
16
17        &lt;token: object&gt; a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = &lt;&gt;) {
23      while ($input =~ m{$rbb}g) {
24          say("matches: &lt;$&amp;&gt;");
25          say Dumper \%/;
26      }
27  }
</PRE>

<P>
Sigue una ejecución del programa anterior:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: &lt;he saw a dog&gt;
$VAR1 = {
          '' =&gt; 'he saw a dog',
          's' =&gt; {
                   '' =&gt; 'he saw a dog',
                   'object' =&gt; 'a dog',
                   'verb' =&gt; 'saw',
                   'noun' =&gt; 'he'
                 }
        };

Jane sees a cat
matches: &lt;Jane sees a cat&gt;
$VAR1 = {
          '' =&gt; 'Jane sees a cat',
          's' =&gt; {
                   '' =&gt; 'Jane sees a cat',
                   'object' =&gt; 'a cat',
                   'verb' =&gt; 'sees',
                   'noun' =&gt; 'Jane'
                 }
        };
</PRE>

<P>

<H4><A NAME="SECTION008111090000000000000">
Ámbito de uso de <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
Cuando se usa <A NAME="tex2html186"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
como parte de 
un programa que utiliza otras regexes hay que evitar 
que <A NAME="tex2html187"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
procese las mismas. <A NAME="tex2html188"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars">Regexp::Grammars</A>
reescribe las expresiones regulares durante la fase de preproceso. Esta por ello 
presenta las mismas limitaciones que cualquier otra forma de 
'source filtering' (véase <A NAME="tex2html189"
  HREF="http://search.cpan.org/perldoc/?perlfilter"><TT>perlfilter</TT></A>). Por ello es una buena idea declarar
la gramática en un bloque <code>do</code> restringiendo de esta forma el ámbito de 
acción del módulo.

<P>
<PRE>
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };
</PRE>

<P>
<HR>
<A NAME="tex2html2562"
  HREF="node87.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2556"
  HREF="node85.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2550"
  HREF="node85.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2558"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2560"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2563"
  HREF="node87.html">Objetos</A>
<B>Sup:</B> <A NAME="tex2html2557"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
<B> Ant:</B> <A NAME="tex2html2551"
  HREF="node85.html">Análisis Sintáctico con Regexp::Grammars</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
