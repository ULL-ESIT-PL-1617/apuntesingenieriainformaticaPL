<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Expresiones Regulares en tiempo de matching</TITLE>
<META NAME="description" CONTENT="Expresiones Regulares en tiempo de matching">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node66.html">
<LINK REL="previous" HREF="node64.html">
<LINK REL="up" HREF="node56.html">
<LINK REL="next" HREF="node66.html">
</HEAD>

<BODY >

<A NAME="tex2html2135"
  HREF="node66.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2129"
  HREF="node56.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2123"
  HREF="node64.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2131"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2133"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2136"
  HREF="node66.html">Expresiones Condicionales</A>
<B>Sup:</B> <A NAME="tex2html2130"
  HREF="node56.html">Algunas Extensiones</A>
<B> Ant:</B> <A NAME="tex2html2124"
  HREF="node64.html">Ejecución de Código dentro</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html2137"
  HREF="node65.html#SECTION00829010000000000000">Paréntesis con memoria dentro de una <I>pattern code expression</I></A>
<LI><A NAME="tex2html2138"
  HREF="node65.html#SECTION00829020000000000000">Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito</A>
<LI><A NAME="tex2html2139"
  HREF="node65.html#SECTION00829030000000000000">Ejemplo: Secuencias de dígitos no repetidos</A>
<LI><A NAME="tex2html2140"
  HREF="node65.html#SECTION00829040000000000000">Palíndromos con independencia del acento</A>
<LI><A NAME="tex2html2141"
  HREF="node65.html#SECTION00829050000000000000">Postponiendo para conseguir recursividad</A>
<LI><A NAME="tex2html2142"
  HREF="node65.html#SECTION00829060000000000000">Caveats</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION00829000000000000000"></A>
<A NAME="subsection:tiempodematching"></A>
<BR>
Expresiones Regulares en tiempo de matching
</H2>

<P>
Los paréntesis especiales:
<PRE>
                (??{ Código Perl })
</PRE>
hacen que el <code>Código Perl</code> sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular. El match continuará 
intentando casar con la expresión regular retornada.

<P>

<H4><A NAME="SECTION00829010000000000000">
Paréntesis con memoria dentro de una <I>pattern code expression</I></A>
</H4>
  

<P>
Los paréntesis en la expresión regular retornada no cuentan
en el patrón exterior. Véase el siguiente 
ejemplo:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              </span><span class="synSpecial">([ab])</span><span class="synConstant">             # save 'a' or 'b' in </span><span class="synSpecial">$</span><span class="synConstant">1</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(??</span><span class="synConstant">{ "</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant">"x3 }</span>)  <span class="synComment"># 3 more of the same as in $1</span>
<span class="synLinenum">    8</span>             };
<span class="synLinenum">    9</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-"</span> <span class="synStatement">if</span> <span class="synConstant">'bbbb'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   10</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-"</span> <span class="synStatement">if</span> <span class="synConstant">'aaaa'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   11</span>   say <span class="synConstant">"&lt;abab&gt; didn't match"</span> <span class="synStatement">unless</span> <span class="synConstant">'abab'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   12</span>   say <span class="synConstant">"&lt;aaab&gt; didn't match"</span> <span class="synStatement">unless</span> <span class="synConstant">'aaab'</span> =~ <span class="synIdentifier">$r</span>;
</pre>
<P>
Como se ve, hemos accedido desde el código interior 
al último paréntesis usando <code>$^N</code>.
Sigue una ejecución:
<PRE>
pl@nereida:~/Lperltesting$ ./postponedregexp.pl
&lt;bbbb&gt; lastpar = 1
&lt;aaaa&gt; lastpar = 1
&lt;abab&gt; didn't match
&lt;aaab&gt; didn't match
</PRE>

<P>

<H4><A NAME="SECTION00829020000000000000">
Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito</A>
</H4>
  

<P>
Consideremos el problema de escribir una expresión regular
que reconoce secuencias no vacías de dígitos tales que la longitud 
de la secuencia restante viene
determinada por el primer dígito.
Esta es una solución:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n intints.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">           </span><span class="synSpecial">(\d)</span><span class="synConstant">                # a digit</span>
<span class="synLinenum">    7</span> <span class="synConstant">           </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">(??</span><span class="synConstant">{</span>
<span class="synLinenum">    8</span> <span class="synConstant">               "</span><span class="synSpecial">\\</span><span class="synConstant">d{</span><span class="synIdentifier">$^</span><span class="synConstant">N}"      # as many as the former</span>
<span class="synLinenum">    9</span> <span class="synConstant">             })                # digit says</span>
<span class="synLinenum">   10</span> <span class="synConstant">           )</span>
<span class="synLinenum">   11</span> <span class="synConstant">          };</span>
<span class="synLinenum">   12</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '3428' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   13</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '228' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   14</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '14' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   15</span> <span class="synConstant">say "24</span> does <span class="synStatement">not</span> match<span class="synConstant">" unless '24' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   16</span> <span class="synConstant">say "4324</span> does <span class="synStatement">not</span> match<span class="synConstant">" unless '4324' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
</pre>
<P>
Cuando se ejecuta se obtiene:
<PRE>
pl@nereida:~/Lperltesting$ ./intints.pl
&lt;3428&gt; &lt;3&gt; &lt;428&gt;
&lt;228&gt; &lt;2&gt; &lt;28&gt;
&lt;14&gt; &lt;1&gt; &lt;4&gt;
24 does not match
4324 does not match
</PRE>

<P>

<H4><A NAME="SECTION00829030000000000000">
Ejemplo: Secuencias de dígitos no repetidos</A>
</H4>
  

<P>
Otro ejemplo: queremos escribir una expresión regular que reconozca secuencias
de  <code>$n</code> dígitos en las que no todos los dígitos se repiten. Donde quizá <code>$n</code> es capturado
de un paréntesis anterior en la expresión regular. Para simplificar la ilustración
de la técnica supongamos que <code>$n = 7</code>:

<pre>
pl@nereida:~$  <span class="dbuser">perl5.10.1 -wdE 0</span>
main::(-e:1):   0
  DB&lt;1&gt;  <span class="dbuser">x join '', map { "(?!".$_."{7})" } 0..9</span>
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB&lt;2&gt;  <span class="dbuser">x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;3&gt;  <span class="dbuser">x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  7777778
  DB&lt;4&gt;  <span class="dbuser">x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;5&gt;  <span class="dbuser">x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  4422444
</pre>

<P>

<H4><A NAME="SECTION00829040000000000000">
Palíndromos con independencia del acento</A>
</H4>
  

<A NAME="parrafo:palindromospostregexp"></A>
<P>
Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
<A HREF="node61.html#parrafo:palabrapalindromos">3.2.5</A>
para reconocer los palabra-palíndromos. 

<P>
Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo <I>dábale arroz a la zorra 
el abad</I>). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion:

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat actionspanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl </span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>;
<span class="synLinenum">    7</span> <span class="synStatement">use </span>Switch;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synStatement">sub</span><span class="synIdentifier"> f </span>{
<span class="synLinenum">   10</span>   <span class="synStatement">my</span> <span class="synIdentifier">$char</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synStatement">switch</span>(<span class="synIdentifier">$char</span>) {
<span class="synLinenum">   13</span>     case [ <span class="synConstant">qw{a á}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[aá]'</span> }
<span class="synLinenum">   14</span>     case [ <span class="synConstant">qw{e é}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[eé]'</span> }
<span class="synLinenum">   15</span>     case [ <span class="synConstant">qw{i í}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[ií]'</span> }
<span class="synLinenum">   16</span>     case [ <span class="synConstant">qw{o ó}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[oó]'</span> }
<span class="synLinenum">   17</span>     case [ <span class="synConstant">qw{u ú}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[uú]'</span> }
<span class="synLinenum">   18</span>     <span class="synStatement">else</span>             { <span class="synStatement">return</span> <span class="synIdentifier">$char</span>  };
<span class="synLinenum">   19</span>   }
<span class="synLinenum">   20</span> }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">   23</span> <span class="synConstant">                            </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">-2</span><span class="synSpecial">)(??</span><span class="synConstant">{ f</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant"> }</span><span class="synSpecial">)</span>
<span class="synLinenum">   24</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant"> </span>
<span class="synLinenum">   25</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span>
<span class="synLinenum">   26</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">                $</span>
<span class="synLinenum">   28</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   31</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   32</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   33</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome"</span>;
<span class="synLinenum">   34</span> }
<span class="synLinenum">   35</span> <span class="synStatement">else</span> {
<span class="synLinenum">   36</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match"</span>;
<span class="synLinenum">   37</span> }
</pre>

<P>
Sigue un ejemplo de ejecución:

<P>

<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$<span class="dbuser"> ./actionspanishpalin.pl </span>
<span class="dbuser">éoíúaáuioé</span>
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dáed</span>
dáed does not match
</pre>

<P>

<H4><A NAME="SECTION00829050000000000000">
Postponiendo para conseguir recursividad</A>
</H4>
  

<P>
Véase el nodo <A NAME="tex2html106"
  HREF="http://www.perlmonks.org/?node_id=585167">Complex regex for maths formulas</A>
para la formulación del problema:

<P>
<BLOCKQUOTE><I>Hiya monks,
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than <code>a-z,A-Z,0-9,+,-,*,/,(,)</code> can be used
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Can anyone offer a hand on how best to tackle this problem?
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>many thanks 
</I></BLOCKQUOTE> 

<P>
La respuesta dada por <A NAME="tex2html107"
  HREF="http://www.perlmonks.org/?node_id=381608">ikegami</A>
usa <code>(?{{ ... })</code>
para conseguir una conducta recursiva en versiones de perl anteriores a la 5.10:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid_expr </span>{
<span class="synLinenum">    6</span>      <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>      <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>      <span class="synIdentifier">$skip</span> = qr! \s* !x;
<span class="synLinenum">   10</span>      <span class="synIdentifier">$term</span> = qr! <span class="synIdentifier">$skip</span> [a-zA-Z]+              <span class="synComment"># A term is an identifier</span>
<span class="synLinenum">   11</span>                | <span class="synIdentifier">$skip</span> [<span class="synConstant">1-9</span>][<span class="synConstant">0-9</span>]*            <span class="synComment"># or a number</span>
<span class="synLinenum">   12</span>                | <span class="synIdentifier">$skip</span> \( (??{ <span class="synIdentifier">$expr</span> }) <span class="synIdentifier">$skip</span> <span class="synComment"># or an expression</span>
<span class="synLinenum">   13</span>                        \)
<span class="synLinenum">   14</span>                !x;
<span class="synLinenum">   15</span>      <span class="synIdentifier">$expr</span> = qr! <span class="synIdentifier">$term</span>                         <span class="synComment"># A expr is a term</span>
<span class="synLinenum">   16</span>                  (?: <span class="synIdentifier">$skip</span> [-+*/] <span class="synIdentifier">$term</span> )*     <span class="synComment"># or a term + a term ...</span>
<span class="synLinenum">   17</span>                !x;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>      <span class="synStatement">return</span> <span class="synIdentifier">$_</span>[<span class="synConstant">0</span>] =~<span class="synStatement"> /</span><span class="synConstant"> ^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant"> </span><span class="synStatement">/x</span>;
<span class="synLinenum">   20</span>   }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">print</span>(is_valid_expr(<span class="synIdentifier">$_</span>) ? <span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">"</span> : <span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant"> is not valid</span><span class="synSpecial">\n</span><span class="synConstant">"</span>) <span class="synStatement">foreach</span> (
<span class="synLinenum">   23</span>    <span class="synConstant">'(a + 3)'</span>,
<span class="synLinenum">   24</span>    <span class="synConstant">'(3 * 4)+(b + x)'</span>,
<span class="synLinenum">   25</span>    <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   26</span>    <span class="synConstant">'3 + 2'</span>,
<span class="synLinenum">   27</span> 
<span class="synLinenum">   28</span>    <span class="synConstant">'!3 + 2'</span>,
<span class="synLinenum">   29</span>    <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>    <span class="synConstant">'3 a'</span>,
<span class="synLinenum">   32</span>    <span class="synConstant">'3 3'</span>,
<span class="synLinenum">   33</span>    <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span>    <span class="synConstant">'2 - 3 * 4'</span>,
<span class="synLinenum">   36</span>    <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   37</span>   );
</pre>

<P>
Sigue el resultado de la ejecución:
<PRE>
pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid
</PRE>

<P>

<H4><A NAME="SECTION00829060000000000000">
Caveats</A>
</H4>
  

<P>
Estos son algunos puntos a tener en cuenta cuando se usan patrones postpuestos.
Véase la entrada <code>(??{ code })</code> en la sección 'Extended-Patterns' en <A NAME="tex2html110"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:

<P>
<BLOCKQUOTE><I>WARNING: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that has
side effects may not perform identically from version to version due to
the effect of future optimisations in the regex engine.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This is a <A NAME="3368"></A><B>postponed regular subexpression</B>. The code is evaluated at
run time, at the moment this subexpression may match. The result of
evaluation is considered as a regular expression and matched as if it
were inserted instead of this construct. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The code <I>is not interpolated</I>. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>As before, the rules to determine where the code ends are currently somewhat convoluted.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Because perl's regex engine is not currently <A NAME="tex2html108"
  HREF="http://en.wikipedia.org/wiki/Reentrant_(subroutine)">re-entrant</A>, delayed code
may not invoke the regex engine either directly with <code>m//</code> or <code>s///</code>),
or indirectly with functions such as <A NAME="tex2html109"
  HREF="http://www.ayni.com/perldoc/functions/split.html"><TT>split</TT></A>.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><I>Recursing</I> deeper than 50 times without consuming any input string will
result in a fatal error. The maximum depth is compiled into perl, so
changing it requires a custom build.
</I></BLOCKQUOTE>

<P>
<HR>
<A NAME="tex2html2135"
  HREF="node66.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2129"
  HREF="node56.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2123"
  HREF="node64.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2131"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2133"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2136"
  HREF="node66.html">Expresiones Condicionales</A>
<B>Sup:</B> <A NAME="tex2html2130"
  HREF="node56.html">Algunas Extensiones</A>
<B> Ant:</B> <A NAME="tex2html2124"
  HREF="node64.html">Ejecución de Código dentro</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
