<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis de Ámbito: Conceptos</TITLE>
<META NAME="description" CONTENT="Análisis de Ámbito: Conceptos">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node284.html">
<LINK REL="previous" HREF="node282.html">
<LINK REL="up" HREF="node282.html">
<LINK REL="next" HREF="node284.html">
</HEAD>

<BODY >

<A NAME="tex2html5754"
  HREF="node284.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html5748"
  HREF="node282.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html5742"
  HREF="node282.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html5750"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html5752"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html5755"
  HREF="node284.html">Descripción Eyapp del Lenguaje</A>
<B>Sup:</B> <A NAME="tex2html5749"
  HREF="node282.html">Análisis de Ámbito</A>
<B> Ant:</B> <A NAME="tex2html5743"
  HREF="node282.html">Análisis de Ámbito</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>
<BR> <P>

<!--End of Navigation Panel-->

<H1><A NAME="SECTION001710000000000000000">
Análisis de Ámbito: Conceptos</A>
</H1>

<P>

<H4><A NAME="SECTION001710010000000000000">
El Problema del Análisis de Ámbito</A>
</H4>
  

<P>
En los lenguajes de programación <A NAME="25070"></A><B>name binding</B> (binding = encuadernado, encarpetado,
ligadura, unificación) es la asociación de valores con identificadores. 
Decimos de un identificador ligado a un valor que es una <B>referencia</B> a dicho valor.
El concepto de binding es un concepto proveído por los lenguajes de programación:
a nivel de máquina no existe el concepto de binding, de relación (nombre, valor).
El concepto de Binding esta intimamente relacionado con el concepto de ámbito
<A NAME="25072"></A><B>scope</B>), ya que el <A NAME="25074"></A><B>análisis de ámbito</B> es la determinación de las relaciones
de binding.

<P>
El problema del análisis de ámbito sería sencillo sino fuera porque 
los lenguajes de programación suelen permitir el uso del mismo
<A NAME="25076"></A><B>nombre</B><A NAME="tex2html271"
  HREF="footnode.html#foot24448"><SUP>12.1</SUP></A> 
para denotar distintos elementos de un
programa. Es por ello que es necesario determinar que definición o declaración
se aplica a una determinada ocurrencia de un elemento.

<P>
<P>
<DIV><B>Definición  12.1.1</B> &nbsp; 
<I>En un lenguaje de programación, una <A NAME="25078"></A><B>declaración</B> es un constructo sintáctico que define y provee información 
sobre un nombre.
La declaración provee información sobre las propiedades asociadas con el uso del nombre: 'este nombre es una función que recibe enteros y
retorna enteros', 'este nombre puede ser usado para referirse a listas de enteros y es visible sólo en el ámbito actual', etc.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  12.1.2</B> &nbsp; 
<I>Las <A NAME="25080"></A><B>reglas de ámbito</B> de un lenguaje determinan que declaración
del nombre es la que se <B>aplica</B> cuando el nombre es usado.</I></DIV><P></P>

<P>

<H4><A NAME="SECTION001710020000000000000">
Binding Estático y Binding Dinámico</A>
</H4>
  

<P>
En la definición anterior no se especifica en que momento se resuelve
la correspondencia (nombre, definición).

<P>
Se habla de <A NAME="25086"></A><B>static binding</B> 
cuando las reglas y la resolución de la  correspondencia (nombre, definición)
puede ser  resuelta en tiempo de compilación, a partir del análisis 
del texto del programa fuente (también se habla de <A NAME="25088"></A><B>early binding</B>).

<P>
Por el contrario cuando se habla de <A NAME="25090"></A><B>dynamic binding</B> 
cuando la determinación de que definición se aplica a un nombre es 
establecida en tiempo de ejecución (también se denomina <A NAME="25092"></A><B>late binding</B> o <A NAME="25094"></A><B>virtual binding</B>).

<P>
Un ejemplo de static binding es una llamada a a una función en C:
la función referenciada por un identificador no puede cambiarse en tiempo 
de ejecución. Un ejemplo de binding dinámico puede ocurrir cuando se trabaja 
con métodos polimorfos en un lenguaje de programación orientada a objetos, 
ya que la definición completa del tipo del objeto no
se conoce hasta el momento de la ejecución. 

<P>
El siguiente ejemplo de <A NAME="tex2html272"
  HREF="http://en.wikipedia.org/wiki/Dynamic_binding">Dynamic_binding</A>tomado de la wikipedia,  
ilustra el binding dinámico. 

<P>
Supongamos que todas las formas de vida son mortales.
En OOP podemos decir que la clase <code>Persona</code> y la clase <code>Planta</code> 
deben implementar los métodos de <code>Mortal</code>, el cual contiene
el método <code>muere</code>.

<P>
Las personas y las plantas mueren de forma diferente, por ejemplo las plantas 
no tienen un corazón que se detenga. Dynamic binding
es la práctica de determinar que definición/declaración se aplica 
a un método en tiempo de ejecución:

<P>
<PRE>
void mata(Mortal m) {
  m.muere();
}
</PRE>

<P>
No esta claro cual es la clase actual de <code>m</code>, una persona o una planta. 
Ambos <code>Planta.muere</code> y <code>Persona.muere</code> pueden ser invocados.
Cuando se usa dynamic binding, el objeto <code>m</code> es examinado en tiempo de 
ejecución para determinar que método es invocado. Esto supone una 'renuncia' por
parte del lenguaje y su compilador a obtener una definición completa del objeto.

<P>
<P>
<DIV><B>Definición  12.1.3</B> &nbsp; 
<I>Cuando se usa <B>static binding</B>,
la parte del texto del programa al cual se aplica la declaración de un 
nombre se denomina <A NAME="25098"></A><B>ámbito de la declaración</B></I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  12.1.1</B> &nbsp; 
<I>En el siguiente código existen dos definiciones para 
el nombre <code>one</code>, una en la línea 11 y otra en la
línea 20.
</I>
<P><PRE>
pl@europa:~/src/perl/perltesting$ cat -n ds.pl
     1  package Father;
     2  use warnings;
     3  use strict;
     4
     5  sub new {
     6    my $class = shift;
     7
     8    bless { @_ }, $class;
     9  }
    10
    11  sub one {
    12    "Executing Father::one\n";
    13  }
    14
    15  package Child;
    16  use warnings;
    17  use strict;
    18  our @ISA = 'Father';
    19
    20  sub one {
    21    "Executing Child::one\n";
    22  }
    23
    24  package main;
    25
    26  for (1..10) {
    27    my $class = int(rand(2)) ? 'Child' : 'Father';
    28    my $c = $class-&gt;new;
    29    print $c-&gt;one;
    30  }
</PRE><I>
¿Que definiciones se aplican a los 10 usos del nombre <code>one</code>
en la línea 28? 
¿Estos usos constituyen un ejemplo de binding estático
o dinámico?
¿Cuál es el ámbito de las declaraciones de <code>one</code>?</I></DIV><P></P>

<P>
Incluso en los casos en los que la resolución del binding se deja para el momento de la ejecución
el compilador debe tener información suficiente para poder generar código. En el caso
anterior, el compilador de Perl infiere de la presencia de la flecha en <code>$c-&gt;one</code> 
que <code>one</code> es el nombre de una subrutina. 

<P>
<P>
<DIV><B>Ejercicio  12.1.2</B> &nbsp; 
<I>En el siguiente ejemplo se usa una referencia simbólica para
acceder a una función:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n symbolic.pl
 1  use warnings;
 2  use strict;
 3
 4  sub one {
 5    "1\n";
 6  }
 7
 8  sub two {
 9    "2\n";
10  }
11
12  my $x = &lt;&gt;;
13  chomp($x);
14
15  no strict 'refs';
16  print &amp;$x();
</PRE><I>
Al ejecutarlo con entrada <code>one</code> obtenenmos:
</I><PRE>
pl@europa:~/src/perl/testing$ perl symbolic.pl
one
1
</PRE><I>
¿El uso de la línea 16 es un ejemplo de binding estático o dinámico?
¿Cuál es el binding de las declaraciones de <code>x</code>?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  12.1.3</B> &nbsp; 
<I>En el siguiente ejemplo la clase <code>Two</code> hereda de <code>One</code>.
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n latebinding.pl
     1  package One;
     2  use warnings;
     3  use strict;
     4
     5  our $x = 1;
     6  sub tutu {
     7    "Inside tutu: x = $x\n";
     8  }
     9
    10  package Two;
    11  use warnings;
    12  use strict;
    13  our @ISA = 'One';
    14
    15  our $x = 2;
    16
    17  print Two-&gt;tutu();
</PRE><I>
¿Qué definición de <code>$x</code> se aplica al uso en la línea 7?
¿Cuál será la salida del programa?</I></DIV><P></P>

<P>
<DIV><B>Definición  12.1.4</B> &nbsp; 
<I>La tarea de asignar las ocurrencias de las declaraciones de nombres a las 
ocurrencias de uso  de los nombres de acuerdo a las reglas de ámbito
del lenguaje se denomina <A NAME="25100"></A><B>identificación de los nombres</B></I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  12.1.5</B> &nbsp; 
<I>Una ocurrencia de un nombre se dice <A NAME="25102"></A><B>local</B> si está en el ámbito 
de una declaración que no se aplica desde el comienzo de la declaración 
hasta el final del texto del programa. Tal declaración
es una <A NAME="25104"></A><B>declaración local</B>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  12.1.6</B> &nbsp; 
<I>Si, por el contrario, una ocurrencia de un nombre está en el ámbito
de una declaración que se aplica desde el comienzo de la declaración 
hasta el final del texto del programa se dice que la declaración
es una <A NAME="25106"></A><B>declaración global</B>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  12.1.7</B> &nbsp; 
<I>Aunque la definición anterior establece el <A NAME="25108"></A><B>atributo ámbito</B>
como un atributo de la declaración es usual y conveniente
hablar del 
</I>
<BLOCKQUOTE><I>"<B>ámbito del nombre <TT>x</TT></B>" 
</I></BLOCKQUOTE><I>
como una abreviación
de 
</I>
<BLOCKQUOTE><I>"<B>el ámbito de la declaración del nombre <TT>x</TT>
que se aplica a esta ocurrencia de <TT>x</TT></B>"
</I></BLOCKQUOTE></DIV><P></P>

<P>

<H4><A NAME="SECTION001710030000000000000">
Intervención del Programador en Tiempo de Compilación</A>
</H4>
  

<P>
En algunos lenguajes - especialmente en los lenguajes dinámicos- la diferenciación 
entre tiempo de compilación y tiempo de ejecución puede ser difusa.
En el siguiente fragmento de código Perl se usa el módulo
 Contextual::Return 
para crear una variable cuya definición cambia 
con la forma de uso.

<P>
<PRE>
lhp@nereida:~/Lperl/src/testing$ cat -n context1.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use Contextual::Return;
 4
 5  my $x = BOOL { 0 } NUM { 3.14 } STR { "pi" };
 6
 7  unless ($x) { warn "¡El famoso número $x (".(0+$x).") pasa a ser falso!\n" } # executed!

lhp@nereida:~/Lperl/src/testing$ context1.pl
¡El famoso número pi (3.14) pasa a ser falso!
</PRE>

<P>
Obsérvese que el binding de <code>$x</code> es estático y que a los 
tres usos de <code>$x</code> en la línea 7 se les asigna la definición 
en la línea 5.
La declaración de <code>$x</code> ocurre en lo que Perl denomina
'tiempo de compilación', 
sin embargo, el hecho de que un módulo cargado en tiempo de compilación
puede ejecutar sentencias permite a  Contextual::Return 
expandir el lenguaje de las declaraciones Perl.

<P>
<P>
<DIV><B>Ejercicio  12.1.4</B> &nbsp; 
<I>Considere el siguiente código Perl:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n contextual.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Contextual::Return;
     4
     5  sub sensible {
     6    return STR { "one" }
     7           NUM { 1 }
     8           LIST   { 1,2,3 }
     9           HASHREF   { {name =&gt; 'foo', value =&gt; 99} }
    10    ;
    11  }
    12
    13  print "Result = ".sensible()."\n";
    14  print "Result = ".(0+sensible())."\n";
    15  print "Result = ",sensible(),"\n";
    16  print "Result = (name = ",sensible()-&gt;{name},", value = ", sensible()-&gt;{value},")\n";
</PRE><I>
Cuando se ejecuta, este programa produce la siguiente salida:
</I><PRE>
pl@europa:~/src/perl/testing$ ./contextual.pl
Result = one
Result = 1
Result = 123
Result = (name = foo, value = 99)
</PRE>
<P>
<I>Las relaciones de definición-uso de la función <code>sensible</code> ¿Son un caso de
binding estático o de binding dinámico?
¿Cuál es el ámbito de la declaración de <code>sensible</code> en las líneas 5-11?</I></DIV><P></P>

<P>

<H4><A NAME="SECTION001710040000000000000">
Visibilidad</A>
</H4>
  

<P>
Como ya sabemos, es falso que en el ámbito de una declaración que define a <code>x</code> 
dicha declaración se aplique a todas las ocurrencias de <code>x</code> en su ámbito.
En un ámbito estático, una declaración local a la anterior puede <A NAME="25118"></A><B>ocultar la visibilidad</B> de 
la declaración anterior de <code>x</code>.

<P>
<P>
<DIV><B>Definición  12.1.8</B> &nbsp; 
<I>Las <A NAME="25120"></A><B>reglas de visibilidad</B> de un lenguaje especifican como se relacionan los nombres
con las declaraciones que se les aplican.</I></DIV><P></P>

<P>
El concepto de nombre depende del lenguaje. 
Algunos lenguajes permiten que en un cierto ámbito haya mas de una definición asociada 
con un identificador.  Un mecanismo que puede ser usado para determinar univocamente que definición
se aplica a un determinado uso de un nombre es que el uso del nombre vaya acompañado
de un sigil.
(podría reinterpretarse que en realidad el nombre de una variable en Perl incluye el sigil).

<P>
Así, en Perl tenemos que es 
legal tener diferentes variables con nombre <code>x</code>: <code>$x</code>, <code>@x</code>, <code>%x</code>, <code>&amp;x</code>, <code>*x</code>,
etc. ya que van prefijadas por diferentes <B>sigils</B> 
<code>$</code>, <code>@</code>, etc. El sigil que prefija <code>x</code> determina que definición se aplica al uso de <code>x</code>
(La palabra sigil hace referencia a 'sellos mágicos' - combinaciones de símbolos 
y figuras geométricas - que son usados en algunas invocaciones con el propósito de producir un
sortilegio).

<P>
En algunos casos existen mecanismos para la
extensión de los nombres.
En Perl es posible acceder a una variable de paquete
ocultada por una léxica usando su nombre completo.

<P>
La asignación de una declaración a ciertos usos de un identificador puede requerir
de otras fases de análisis semántico, como el análisis de tipos.
El uso de los nombres de campo de un registro en  Pascal y en C 
constituye un ejemplo:

<P>
<PRE>
 1	type 
 2	  a = ^b;
 3	  b = record
 4	        a: Integer;
 5	        b: Char;
 6	        c: a
 7	      end;
 8	var
 9	  pointertob: a;
10	  c         : Integer;
11	
12	...
13	new(pointertob);
14	
15	pointertob^.c := nil;
16	c             := 4;
17	...
</PRE>

<P>
El uso de <code>c</code> en la ĺinea 15 es posible porque el tipo de la expresión <code>pointertob^</code>
es un registro. La definición que se aplica al uso de <code>c</code> en la línea 16 es la de la línea 10.

<P>
También es posible hacer visible un nombre escondido - sin necesidad de extender el identificador - 
mediante alguna directiva que lo haga visible: 
Un ejemplo es la declaración <code>with</code> the Pascal:

<P>
<PRE>
new(pointertob);
 
with pointertob^ do
begin
  a := 10;
  b := 'A';
  c := nil
end;
...
</PRE>

<P>

<H4><A NAME="SECTION001710050000000000000">
Declaraciones y Definiciones</A>
</H4>
  

<P>
En algunos lenguajes se distingue entre declaraciones que sólo proporcionan información sobre el elemento
y lo hacen <B>visible</B> - pero no asignan memoria o producen código para la implementación del mismo - y otras
que si producen dicho código. A las primeras se las suele llamar declaraciones
y a las segundas definiciones.
En tales lenguajes se considera un error que dos declaraciones de un mismo elemento difieran.

<P>
Por ejemplo, en C una variable o función sólo es definida una vez,
pero puede ser declarada varias veces.
El calificativo <code>extern</code> es usado en C para indicar que una declaración provee
visibilidad pero no conlleva definición (creación):

<P>
<PRE>
extern char stack[10];
extern int stkptr;
</PRE>

<P>
Estas declaraciones le dicen al compilador C que las definiciones de los nombres
<code>stack</code> y <code>stackptr</code> se encuentran en otro fichero. 
Si la palabra <code>extern</code> fuera omitida el compilador asignaría memoria para
las mismas.

<P>
Otro ejemplo en el que una directiva hace visible una definición escondida
es el uso de la declaración  our  de Perl cuando un paquete está repartido
entre varios ficheros que usan repetitivamente <code>strict</code>:

<P>
<P>
<DIV><B>Ejercicio  12.1.5</B> &nbsp; 
<I>Considere el siguiente programa:
</I><PRE>
pl@europa:~/src/perl/perltesting$ cat -n useA.pl
     1  #!/usr/bin/perl
     2  package A;
     3  use warnings;
     4  use strict;
     5
     6  use A;
     7
     8  #our $x;
     9  print "$x\n";
</PRE><I>
La variable <code>$x</code> esta declarada en el fichero <code>A.pm</code>:
</I><PRE>
pl@europa:~/src/perl/perltesting$ cat -n A.pm
     1  package A;
     2  use warnings;
     3  use strict;
     4
     5  our $x = 1;
     6
     7  1;
</PRE>
<P>
<I>Sin embargo la compilación de <code>useA.pl</code> produce errores,
pues <code>$x</code> no es visible:
</I><PRE>
pl@europa:~/src/perl/perltesting$ perl -c useA.pl
Variable "$x" is not imported at useA.pl line 9.
Global symbol "$x" requires explicit package name at useA.pl line 9.
useA.pl had compilation errors.
</PRE><I>
El mensaje se arregla descomentando la declaración de <code>$x</code>
en la línea 8 de <code>useA.pl</code>:
</I><PRE>
pl@europa:~/src/perl/perltesting$ perl -ce `sed -e 's/#our/our/' useA.pl`
-e syntax OK
</PRE><I>
La declaración de la línea 8 hace visible la variable <code>$x</code> en el
fichero <code>useA.pl</code>. 
</I>
<P>
<I>¿Cual es entonces el ámbito de la declaración de <code>$x</code> en la línea 5 de 
<code>A.pm</code>? ¿Es todo el paquete? ¿O sólo el segmento del paquete que está en
el fichero <code>A.pm</code>? (se supone que trabajamos con <code>strict</code> activado).</I></DIV><P></P>

<P>

<H4><A NAME="SECTION001710060000000000000">
Inferencia, Declaraciones Implícitas y Ámbito</A>
</H4>
  

<P>
<P>
<DIV><B>Ejercicio  12.1.6</B> &nbsp; 
<I>Tanto en los lenguajes estáticos como en los dinámicos
se suele requerir que exista una declaración del objeto usado que determine las propiedades del mismo.
</I>
<P>
<I>Aunque en los lenguajes dinámicos la creación/definición del elemento asociado
con un nombre puede postergarse hasta el tiempo de ejecución, la generación de
código para la sentencia de uso suele requerir un conocimiento (aunque sea
mínimo) del objeto que esta siendo usado. En algunos casos, es necesario
inferir la declaración a partir del uso, de manera que la declaración asociada
con un uso es construida a partir del propio uso.
</I>
<P>
<I>Los lenguajes típicamente estáticos fuertemente tipeados suelen requerir que
para todo uso exista una declaración explícita y completa del nombre y de las
operaciones que son válidas sobre el mismo al finalizar la fase de compilación.
Sin embargo, el código para la creación/definición de algunos objetos puede ser
postergado a la fase de enlace. De hecho, la resolución de ciertos enlaces
pueden ocurrir durante la fase de ejecución (énlace dinámico). 
</I>
<P>
<I>El siguiente ejemplo hace uso de un typeglob selectivo en la línea 8 para 
definir la función <code>ONE</code>:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n glob.pl
     1  use warnings;
     2  use strict;
     3
     4  sub one {
     5    "1\n"
     6  }
     7
     8  *ONE = \&amp;one;
     9  print ONE();
</PRE><I>
Al ejecutar este programa se produce la salida;
</I><PRE>
pl@europa:~/src/perl/testing$ perl glob.pl
1
</PRE><I>
 ¿El uso de <code>ONE</code> en la línea 9 es un ejemplo de binding estático o dinámico?
¿Cuál es el ámbito de la declaración de <code>ONE</code>?
</I>
<P>
<I>Responda estas mismas preguntas para esta otra variante del ejemplo anterior:
</I>
<P><PRE>
pl@nereida:~/src/perl/perltesting$ cat -n coderef.pl
     1  use warnings;
     2  use strict;
     3
     4  *ONE = sub { "1\n" };
     5  print ONE();
</PRE></DIV><P></P>

<P>
En los ejemplos anteriores el propio uso del nombre <code>ONE</code> 
actúa como una declaración: Perl deduce 
de la presencia de paréntesis después de <code>ONE</code> que <code>ONE</code> es el nombre de una función.
Esta información es suficiente para generar el código necesario. Podría decirse
que la forma del uso declara al ente <code>ONE</code> y que la línea de uso conlleva una declaración
implícita. Sin embargo, la creación/definición completa de <code>ONE</code> es postergada hasta la fase de 
ejecución.

<P>
<P>
<DIV><B>Ejercicio  12.1.7</B> &nbsp; 
<I>La conducta del compilador de Perl cambia si se sustituye el programa anterior por este otro:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n globwarn.pl
     1  use warnings;
     2  use strict;
     3
     4  sub one {
     5    "1\n"
     6  }
     7
     8  *ONE = \&amp;one;
     9  my $x = ONE;
    10  print $x;
</PRE><I>
Al compilar se obtiene un error:
</I><PRE>
pl@europa:~/src/perl/testing$ perl -c globwarn.pl
Bareword "ONE" not allowed while "strict subs" in use at globwarn.pl line 9.
globwarn.pl had compilation errors.
</PRE><I>
¿Sabría explicar la causa de este cambio de conducta?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  12.1.8</B> &nbsp; 
<I>El error que se observa en el ejercicio anterior desaparece 
cuando se modifica el código como sigue:
</I><PRE>
lusasoft@LusaSoft:~/src/perl/perltesting$ cat -n globheader.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use strict;
     4
     5  sub ONE;
     6
     7  sub one {
     8    "1\n"
     9  }
    10
    11  *ONE = \&amp;one;
    12  my $x = ONE;
    13  print $x;
</PRE><I>
¿Cual es el significado de la línea 5?</I></DIV><P></P>

<P>
En el caso del lenguaje Simple C introducido en la práctica 
<A HREF="node285.html#practica:esquemadetradsimple">12.3</A>
hay una única declaración que se aplica a cada 
ocurrencia correcta de un nombre en el ámbito de dicha declaración.

<P>
Esto no tiene porque ser siempre así: en ciertos lenguajes 
una redeclaración de un cierto nombre <code>x</code> puede que sólo oculte 
a otra declaración previa de <code>x</code> si las dos declaraciones
asignan el mismo tipo a <code>x</code>. Esta idea suele conocerse
como <A NAME="25130"></A><B>sobrecarga de identificadores</B>. De todos modos, sigue 
siendo cierto que para que el programa
sea considerado correcto es necesario que sea posible <I>inferir</I>
para cada ocurrencia de un identificador que única definición se
aplica. Así una llamada  a una cierta función
<code>min(x,y)</code> llamaría a diferentes 
funciones <code>min</code> según fueran los tipos de <code>x</code> e <code>y</code>.
Para resolver este caso es necesario combinar las fases
de análisis de ámbito y de análisis de tipos.

<P>
Algunos lenguajes - especialmente los lenguajes funcionales - logran eliminar la mayoría 
de las declaraciones. Disponen de un mecanismo de inferencia que les permite - en
tiempo de compilación - deducir
del uso la definición y propiedades del nombre. 

<P>
Véase como ejemplo de inferencia la siguiente sesión en <A NAME="tex2html273"
  HREF="http://en.wikipedia.org/wiki/OCaml">OCaml</A>
<PRE>
pl@nereida:~/src/perl/attributegrammar/Language-AttributeGrammar-0.08/examples$ ocaml
        Objective Caml version 3.09.2

# let minimo = fun i j -&gt; if i&lt;j then i else j;;
val minimo : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
# minimo 2 3;;
- : int = 2
# minimo 4.9 5.3;;
- : float = 4.9
# minimo "hola" "mundo";;
- : string = "hola"
</PRE>

<P>
El compilador <code>OCaml</code> infiere el tipo de las expresiones. 
Así el tipo asociado con la función <code>minimo</code> es

<P>
<PRE>
                    'a -&gt; 'a -&gt; 'a
</PRE>

<P>
que es una <A NAME="25134"></A><B>expresión de tipo</B> que contiene
<A NAME="25136"></A><B>variables de tipo</B>. El operador <code>-&gt;</code> es asociativo a derechas
y asi la expresión debe ser leída como <code>'a -&gt; ('a -&gt; 'a)</code>. 
Básicamente dice: 

<P>
El tipo de la expresión es una función que toma un argumento de tipo <code>'a</code>
(donde <code>'a</code> es una variable tipo que será instanciada en el momento del
uso de la función) y devuelve una función que toma elementos de tipo <code>'a</code>
y retorna elementos de tipo <code>'a</code>. 

<P>

<H4><A NAME="SECTION001710070000000000000">
Ámbito Dinámico</A>
</H4>
  

<P>
En el <A NAME="25142"></A><B>ámbito dinámico</B>, cada nombre para el que se usa ámbito dinámico
tiene asociada una pila de bindings. Cuando se crea un nuevo ámbito
dinámico se empuja en la pila el viejo valor (que podría no estar definido).
Cuando se sale del ámbito se saca de la pila el antiguo valor.
La evaluación de <code>x</code> retorna siempre el valor en el top de la pila.

<P>
La sentencia  local  de Perl provee de ámbito dinámico
a las variables de paquete.
Una aproximaci&#243;n a lo que ocurre cuando se ejecuta 
<code>local</code> es:

<P>
<BR>
<BR>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>DECLARACI&#211;N  DE <code>local</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>SIGNIFICADO</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><PRE>
{
  local($SomeVar);
  $SomeVar = 'My Value';
       ...
}
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><PRE>
{
  my $TempCopy = $SomeVar;
  $SomeVar = undef;
  $SomeVar = 'My Value';
       ...
  $SomeVar = $TempCopy;
}
</PRE></TD>
</TR>
</TABLE>
</DIV>
<BR>
<BR>

<P>
La diferencia entre ámbito dinámico y estático debería quedar mas clara observando
la conducta del siguiente código

<P>
<PRE>
lhp@nereida:~/Lperl/src$ cat -n local.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  our $x;
 5
 6  sub pr { print "$x\n"; }
 7  sub titi { my $x = "titi"; pr(); }
 8  sub toto { local $x = "toto"; &amp;pr(); &amp;titi(); }
 9
10  $x = "global";
11  &amp;pr();
12  &amp;toto();
13  &amp;titi();
</PRE>

<P>
Cuando se ejecuta, se obtiene la siguiente salida:

<P>
<PRE>
&gt; local.pl
global
toto
toto
global
</PRE>

<P>
<P>
<DIV><B>Ejercicio  12.1.9</B> &nbsp; 
<I>¿Es <code>local</code> una declaración o una sentencia?
¿Que declaraciones se aplican a los diferentes 
usos de <code>$x</code> en las líneas 6, 7, 8 y 10?.</I></DIV><P></P>

<P>
<BR> <HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL>
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html5756"
  HREF="node283.html#SECTION001710010000000000000">El Problema del Análisis de Ámbito</A>
<LI><A NAME="tex2html5757"
  HREF="node283.html#SECTION001710020000000000000">Binding Estático y Binding Dinámico</A>
<LI><A NAME="tex2html5758"
  HREF="node283.html#SECTION001710030000000000000">Intervención del Programador en Tiempo de Compilación</A>
<LI><A NAME="tex2html5759"
  HREF="node283.html#SECTION001710040000000000000">Visibilidad</A>
<LI><A NAME="tex2html5760"
  HREF="node283.html#SECTION001710050000000000000">Declaraciones y Definiciones</A>
<LI><A NAME="tex2html5761"
  HREF="node283.html#SECTION001710060000000000000">Inferencia, Declaraciones Implícitas y Ámbito</A>
<LI><A NAME="tex2html5762"
  HREF="node283.html#SECTION001710070000000000000">Ámbito Dinámico</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>
<A NAME="tex2html5754"
  HREF="node284.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html5748"
  HREF="node282.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html5742"
  HREF="node282.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html5750"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html5752"
  HREF="node322.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="PL.jpg"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/0910/course/view.php?id=1148"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="hatpl.png"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="pl.ps"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="perl_errata_form.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="icon_errata.jpg"
 ALT="errata"></A><A NAME="tex2html6"
  HREF="http://search.cpan.org/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html7"
  HREF="http://www.perlmonks.org/?node=Seekers of Perl Wisdom"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="monk.gif"
 ALT="perlmonks"></A><A NAME="tex2html8"
  HREF="http://perldoc.perl.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html9"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/"><IMG
  WIDTH="22" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLHP.jpg"
 ALT="apuntes LHP"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.etsii.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://nereida.deioc.ull.es/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html5755"
  HREF="node284.html">Descripción Eyapp del Lenguaje</A>
<B>Sup:</B> <A NAME="tex2html5749"
  HREF="node282.html">Análisis de Ámbito</A>
<B> Ant:</B> <A NAME="tex2html5743"
  HREF="node282.html">Análisis de Ámbito</A>
 <B>Err:</B> <a href="perl_errata_form.html" target="_blank">Si hallas una errata ...</a>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-03-05</I>
</ADDRESS>
</BODY>
</HTML>
